---
title: "The Effects of Climate Change on the Breeding Success and Timing of African White-backed Vultures"
author: "Mieke Deyzel"
output: html_document
format:
  html:
    embed-resources: true
---
::: {.panel-tabset}
```{r}
#| label: setup 
#| include: false

prep_aictab_bar <- function(aic_obj, panel_label) {
  df <- as.data.frame(aic_obj)

  if (!("dAICc" %in% names(df))) {
    if ("Delta_AICc" %in% names(df)) df$dAICc <- df$Delta_AICc
    else stop("Can't find dAICc / Delta_AICc.")
  }

  if (!("label" %in% names(df))) {
    if ("Modnames" %in% names(df)) df$label <- df$Modnames
    else df$label <- rownames(df)
  }

  best <- min(df$dAICc, na.rm = TRUE)

  df |>
    mutate(panel = panel_label, is_best = dAICc == best) |>
    select(panel, label, dAICc, is_best)
}
 
```
  
## Packages   
 
```{r}
#remotes::install_github("ropensci/rnoaa")
#remotes::install_github("ropensci/chirps")
#install.packages("GSODR")
#install.packages("AICcmodavg")
#install.packages("tinytex")
```

### Load Libraries
```{r}
library(tidyverse)
library(lubridate)
library(janitor)
library(MASS)
library(patchwork)
library(stringr)
library(tibble) 
library(dplyr)
library(knitr)
library(ggplot2)
library(GGally)
library(tidyr)
library(chirps)
library(GSODR)
library(tibble)
library(knitr)
library(AICcmodavg)
library(lme4)
library(tinytex)

```

```{r}
conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter", "dplyr")
conflicted::conflict_prefer("lag", "dplyr")

```

### Overdispersion Check 

```{r}
check_overdispersion <- function(model) {
  rp <- residuals(model, type = "pearson")
  disp <- sum(rp^2) / model$df.residual
  disp
} 
```


## Load Data

```{r}
vultures    <- read.csv("~/Desktop/Vulture Project/Data/93_24 cleaned.csv")
# WeatherData <- read.csv("~/Desktop/Vulture Project/Data/Weather.csv")
```

### Weather Data 

```{r}
library(rnoaa)
library(tidyverse)
library(lubridate)

 
kim_station <- "684380-99999"

weather_raw <- get_GSOD(
  station = kim_station,
  years   = 1992:2024
)



```

```{r}
WeatherData <- weather_raw |>
  transmute(
    YEAR,
    MONTH,
    DAY,
    TEMP,
    MAX,
    MIN,
    PRCP,
    WDSP,
    MXSPD,
    I_HAIL
  ) |>
  arrange(YEAR, MONTH, DAY)

```

### CHIRPS Rainfall for 2004 

```{r}
# coordinates  (24.81 E, 28.62 S)

lonlat <- data.frame(
lon = 24.81,
lat = -28.62
)

kimberley_chirps_2004 <- get_chirps(
object   = lonlat,
dates    = c("2004-01-01", "2004-12-31"),
server   = "ClimateSERV",
as.matrix = FALSE
)

glimpse(kimberley_chirps_2004)

```

### CHIRPS Rainfall for 2004 (Dronfield / Kimberley)

```{r}
daily_chirps_2004 <- tibble(
date    = as.Date(kimberley_chirps_2004$date),
rain_mm = as.numeric(kimberley_chirps_2004$chirps)
)

head(daily_chirps_2004) 
summary(daily_chirps_2004$rain_mm)

annual_chirps_2004 <- daily_chirps_2004 |>
mutate(YEAR = year(date)) |>
group_by(YEAR) |>
summarise(
total_rain_2004 = sum(rain_mm, na.rm = TRUE),
max_rain_2004   = max(rain_mm, na.rm = TRUE),
rain_days_2004  = sum(rain_mm > 0, na.rm = TRUE),
.groups = "drop"
)

annual_chirps_2004

``` 


```{r}
total_rain_2004 <- annual_chirps_2004$total_rain_2004
max_rain_2004   <- annual_chirps_2004$max_rain_2004
rain_days_2004  <- annual_chirps_2004$rain_days_2004

total_rain_2004
max_rain_2004
rain_days_2004

```

### Weather Data 

```{r}
WeatherData_clean <- WeatherData |>
  filter(
    YEAR >= 1992,
    YEAR <= 2024
  ) |>
  mutate(
    date = make_date(YEAR, MONTH, DAY)
  ) |>
  # add CHIRPS daily rainfall into 2004 
  left_join(daily_chirps_2004, by = "date") |>
  mutate(
    PRCP = if_else(YEAR == 2004 & !is.na(rain_mm), rain_mm, PRCP)
  ) |>
  dplyr::select(-rain_mm) 


```

## Clean breeding data 

```{r}
vultures.clean <- vultures |>
  clean_names() |>                               # ringing_date, laying_date
  rename_with(~ gsub("_", ".", .x)) |>           # ringing.date, laying.dater
  mutate(
    ringing.date = ringing.date |> as.character() |> str_trim(),
    ringing.date = if_else(ringing.date %in% c("", "NA", "?"),
                           NA_character_, ringing.date),
    ringing.date = ymd(gsub("/", "-", ringing.date)),
    
    laying.date  = laying.date |> as.character() |> str_trim(),
    laying.date  = if_else(laying.date %in% c("", "NA", "?"),
                           NA_character_, laying.date),
    laying.date  = ymd(gsub("/", "-", laying.date))
  )
```

## Explore Data 

```{r}
glimpse(vultures.clean)
summary(vultures.clean)
colSums(is.na(vultures.clean))

```

### Active Nests per year 

```{r}
active.nests.raw <- vultures.clean |>
mutate(year = year(ringing.date)) |>
group_by(year) |>
summarise(active_nests = n(), .groups = "drop")

ggplot(active.nests.raw, aes(x = year, y = active_nests)) +
geom_col(fill = "#89c5d6", alpha = 0.85) +
labs(x = "Year", y = "Number of active nests") +
theme_bw() +
theme(panel.grid = element_blank())

```

### Success proportion

```{r}
failed.nests.raw <- vultures.clean |>
mutate(year = year(ringing.date)) |>
group_by(year) |>
summarise(
active_nests  = n(),
success_nests = sum(!is.na(laying.date)),
success_prop  = success_nests / active_nests,
.groups       = "drop"
)

ggplot(failed.nests.raw, aes(x = success_prop)) +
  geom_histogram(bins = 15, fill = "#89c5d6") +
  labs(x = "Breeding success proportion", y = "Count") +
  theme_bw() +
  theme(panel.grid = element_blank())

```
```{r}
failed.nests.raw <- failed.nests.raw |>
  mutate(fail_prop = 1 - success_prop)
```

```{r}
library(dplyr)
library(ggplot2)

# If you don't already have fail_prop:
# failed.nests.raw <- failed.nests.raw %>%
#   mutate(fail_prop = 1 - success_prop)

# 1) Fit a simple linear model
mod_fail <- lm(fail_prop ~ active_nests, data = failed.nests.raw)

# 2) Build prediction dataframe for ribbon + line
newdat <- data.frame(
  active_nests = seq(
    min(failed.nests.raw$active_nests, na.rm = TRUE),
    max(failed.nests.raw$active_nests, na.rm = TRUE),
    length.out = 200
  )
)

pr <- predict(mod_fail, newdata = newdat, interval = "confidence")

pred_fail <- cbind(newdat, as.data.frame(pr))
names(pred_fail) <- c("x", "fit", "lwr", "upr")

# 3) Plot (matching your aesthetic)
ggplot() +
  geom_point(
    data = failed.nests.raw,
    aes(x = active_nests, y = fail_prop),
    colour = "#B1BD8C",
    alpha = 0.7,
    size = 2.6
  ) +
  geom_ribbon(
    data = pred_fail,
    aes(x = x, ymin = lwr, ymax = upr),
    fill = "#D5D6D2",
    alpha = 0.4
  ) +
  geom_line(
    data = pred_fail,
    aes(x = x, y = fit),
    colour = "#D5D6D2",
    linewidth = 1.2
  ) +
  labs(
    x = "Number of active nests",
    y = "Proportion of nests failing"
  ) +
  theme_bw(base_family = "Times New Roman") +
  theme(
    panel.grid = element_blank(),
    axis.title = element_text(face = "bold", size = 12),
    axis.text  = element_text(face = "bold", size = 12)
  )
```


### Annual Weather Summaries 

```{r}
weather_yearly <- WeatherData_clean |>
group_by(YEAR) |>
summarise(
mean_temp  = mean(TEMP, na.rm = TRUE),
max_temp   = max(MAX, na.rm = TRUE),
min_temp   = min(MIN, na.rm = TRUE),
total_rain = sum(PRCP, na.rm = TRUE),
max_rain   = max(PRCP, na.rm = TRUE),
rain_days  = sum(PRCP > 0, na.rm = TRUE),
mean_wind  = mean(WDSP, na.rm = TRUE),
max_wind   = max(MXSPD, na.rm = TRUE),
hail_days  = sum(I_HAIL, na.rm = TRUE),
.groups    = "drop"
)

# Check the corrected 2004 rainfall

weather_yearly[weather_yearly$YEAR == 2004,
c("YEAR", "total_rain", "max_rain", "rain_days")]

```

### Plot Annual Rainfall

```{r}
ggplot(weather_yearly, aes(x = YEAR, y = total_rain)) +
geom_line() +
geom_point() +
theme_bw() +
labs(x = "Year", y = "Total annual rainfall (mm)")

```

### Rain over time 

```{r}
library(grid) 

rain_yearly <- weather_yearly

rain_long <- rain_yearly |>
pivot_longer(
cols = c(total_rain, max_rain, rain_days),
names_to = "metric",
values_to = "value"
) |>
mutate(
metric = factor(
metric,
levels = c("total_rain", "max_rain", "rain_days")
),
metric_label = case_when(
metric == "total_rain" ~ "Total annual rainfall (mm)",
metric == "max_rain"   ~ "Max daily rainfall (mm)",
metric == "rain_days"  ~ "Number of rainy days (> 0 mm)"
),
metric_label = factor(
metric_label,
levels = c(
"Total annual rainfall (mm)",
"Max daily rainfall (mm)",
"Number of rainy days (> 0 mm)"
)
)
)

ggplot(rain_long, aes(x = YEAR, y = value)) +
geom_line(linewidth = 0.7) +
geom_point(size = 1.3) +
facet_wrap(~ metric_label, ncol = 1, scales = "free_y") +
theme_classic() +
labs(
x = "Year",
y = NULL
) +
theme(
strip.text    = element_text(size = 9, face = "bold"),
axis.title.x  = element_text(size = 10),
axis.text     = element_text(size = 8),
panel.spacing = unit(0.7, "lines")
)

```

### Check min temp 

```{r}
# Yearly 

ggplot(weather_yearly, aes(x = YEAR, y = min_temp)) +
geom_line() +
geom_point() +
theme_bw() +
labs(x = "Year", y = "Annual minimum temperature (°C)")

```

```{r}
# Temperature trends
summary(lm(mean_temp ~ YEAR, data = weather_yearly))
summary(lm(max_temp ~ YEAR, data = weather_yearly))
summary(lm(min_temp ~ YEAR, data = weather_yearly))

# Rainfall trends
summary(lm(total_rain ~ YEAR, data = weather_yearly))
summary(lm(rain_days ~ YEAR, data = weather_yearly))
summary(lm(max_rain ~ YEAR, data = weather_yearly))

# Wind trends
summary(lm(mean_wind ~ YEAR, data = weather_yearly))
summary(lm(max_wind ~ YEAR, data = weather_yearly))
```


```{r}
# Daily 

weather_daily <- WeatherData_clean |>
group_by(YEAR, MONTH, DAY) |>
summarise(
mean_temp  = mean(TEMP, na.rm = TRUE),
max_temp   = max(MAX,  na.rm = TRUE),
min_temp   = min(MIN,  na.rm = TRUE),
total_rain = sum(PRCP, na.rm = TRUE),
max_rain   = max(PRCP, na.rm = TRUE),
rain_days  = sum(PRCP > 0, na.rm = TRUE),
mean_wind  = mean(WDSP, na.rm = TRUE),
max_wind   = max(MXSPD, na.rm = TRUE),
hail_days  = sum(I_HAIL, na.rm = TRUE),
.groups    = "drop"
)

temp_daily <- weather_daily |>
mutate(
min_temp = ifelse(is.infinite(min_temp), NA_real_, min_temp),
max_temp = ifelse(is.infinite(max_temp), NA_real_, max_temp)
)

summary(temp_daily$min_temp)
summary(temp_daily$max_temp)


```

### Yearly temp summaries 

```{r}
weather_yearly_temp <- weather_daily |>
filter(YEAR >= 1992, YEAR <= 2024) |>
group_by(YEAR) |>
summarise(
mean_temp = mean(mean_temp, na.rm = TRUE),
max_temp  = max(max_temp, na.rm = TRUE),
min_temp  = min(min_temp, na.rm = TRUE),
.groups   = "drop"
)

summary(weather_yearly_temp$min_temp)
summary(weather_yearly_temp$max_temp)

```

### Temps over time 

```{r}
min_temp <- ggplot(weather_yearly_temp, aes(YEAR, min_temp)) +
geom_line() +
geom_point() +
theme_bw() +
labs(x = "Year", y = "Annual minimum temperature (°C)")

max_temp <- ggplot(weather_yearly_temp, aes(x = YEAR, y = max_temp)) +
geom_line() +
geom_point() +
theme_bw() +
labs(
x = "Year",
y = "Annual maximum temperature (°C)",
title = "Annual Maximum Temperature (1993–2024)"
)

mean_temp <- ggplot(weather_yearly_temp, aes(x = YEAR, y = mean_temp)) +
geom_line() +
geom_point() +
theme_bw() +
labs(
x = "Year",
y = "Annual mean temperature (°C)",
title = "Annual Mean Temperature (1993–2024)"
)

```

```{r}
temp_yearly_long <- weather_yearly_temp |>
pivot_longer(
cols = c(max_temp, min_temp, mean_temp),
names_to = "type",
values_to = "value"
) |>
mutate(
type = factor(
type,
levels = c("max_temp", "min_temp", "mean_temp"),
labels = c("Annual Maximum Temperature (°C)",
"Annual Minimum Temperature (°C)",
"Annual Mean Temperature (°C)")
)
)

ggplot(temp_yearly_long, aes(x = YEAR, y = value)) +
geom_line(size = 0.7) +
geom_point(size = 1.5) +
facet_wrap(~ type, scales = "free_y", ncol = 1) +
theme_classic(base_size = 11) +
theme(
strip.text   = element_text(size = 10, face = "bold"),
axis.title   = element_text(size = 9),
axis.text    = element_text(size = 8),
panel.spacing = unit(0.8, "lines")
) +
labs(
x = "Year",
y = "",
title = "Annual Temperature Trends (1993–2024)"
)

```

### Lagged Weather summaries 

```{r}
weather_yearly_lag <- weather_yearly |>
arrange(YEAR) |>
mutate(
across(
c(mean_temp, max_temp, min_temp, total_rain, max_rain,
rain_days, mean_wind, max_wind, hail_days),
~ lag(.x, 1), .names = "lag_{.col}"
)
)

```

### Daily weather with lagged variables 
```{r}
weather_lag <- WeatherData_clean |>
mutate(
mean_temp = readr::parse_number(as.character(TEMP)),
max_temp  = readr::parse_number(as.character(MAX)),
min_temp  = readr::parse_number(as.character(MIN)),
mean_wind = readr::parse_number(as.character(WDSP)),
max_wind  = readr::parse_number(as.character(MXSPD)),
rain      = readr::parse_number(as.character(PRCP)),
rain_day  = as.integer(replace_na(rain, 0) > 0),
hail      = I_HAIL
) |>
arrange(date)
 
```

### Check for weather correlation 

```{r}
weather_yearly |>
  dplyr::select(
    mean_temp, max_temp, min_temp,
    total_rain, max_rain, rain_days,
    mean_wind, max_wind, hail_days
  )


```

```{r}
library(Hmisc)


vars <- weather_yearly |>
  dplyr::select(mean_temp, max_temp, min_temp, total_rain, max_rain,
                rain_days, mean_wind, max_wind, hail_days)

res <- rcorr(as.matrix(vars), type = "pearson")

cor_mat <- res$r
p_mat   <- res$P

cor_df <- as.data.frame(cor_mat) |>
  rownames_to_column("var1") |>
  pivot_longer(-var1, names_to = "var2", values_to = "cor") |>
  mutate(p = as.vector(p_mat))

cor_df <- cor_df |>
  mutate(sig = case_when(
    is.na(p) ~ "",
    p < 0.001 ~ "***",
    p < 0.01  ~ "**",
    p < 0.05  ~ "*",
    TRUE      ~ ""
  ))

```


```{r}
ggplot(cor_df, aes(x = var1, y = var2, fill = cor)) +
  geom_tile() +
  geom_text(aes(label = sig), size = 4) +
  scale_fill_gradient2(
    low = "#b2182b", mid = "white", high = "#2166ac",
    midpoint = 0, limits = c(-1, 1)
  ) +
  labs(x = "", y = "", fill = "Correlation") +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid  = element_blank()
  )


```

 
### All weather across years

```{r}
library(tidyverse)

weather_long <- weather_yearly |>
  select(
    YEAR,
    mean_temp, max_temp, min_temp,
    total_rain, rain_days, max_rain,
    mean_wind, max_wind, hail_days
  ) |>
  pivot_longer(
    -YEAR,
    names_to = "variable",
    values_to = "value"
  ) |>
  mutate(
    variable = recode(variable,
      mean_temp  = "Mean temp",
      max_temp   = "Max temp",
      min_temp   = "Min temp",
      total_rain = "Total rain",
      rain_days  = "Rain days",
      max_rain   = "Max rain",
      mean_wind  = "Mean wind",
      max_wind   = "Max wind",
      hail_days  = "Hail days"
    )
  )

ggplot(weather_long, aes(x = YEAR, y = value)) +
  geom_line(colour = "grey45", linewidth = 0.6) +
  geom_smooth(
    method = "lm",
    se = FALSE,
    colour = "#B1BD8C",
    linewidth = 0.8
  ) +
  facet_wrap(~ variable, scales = "free_y") +
  theme_bw(base_size = 12) +
  theme(
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  strip.background = element_rect(fill = "grey92", colour = NA),
  strip.text = element_text(face = "bold"),
  axis.title = element_text(face = "bold"),
  axis.text.x = element_blank(),
  axis.ticks.x = element_line()
) +
  labs(
    x = "Year",
    y = NULL
  )
```



### Trends over time for breeding cycle variables:

### Number of active nests

```{r}
summary(lm(active_nests ~ year, data = active.nests))

```

### Success

```{r}
laying_success_yearly <- vultures.clean |>
  mutate(year = year(ringing.date)) |>
  filter(!is.na(year)) |>
  group_by(year) |>
  summarise(
    active_nests  = n(),
    success_nests = sum(!is.na(laying.date)),
    failed_nests  = active_nests - success_nests,
    success_prop  = success_nests / active_nests,
    .groups = "drop"
  ) |>
  filter(active_nests > 0)

success_year <- glm(
  cbind(success_nests, failed_nests) ~ year,
  family = binomial,
  data   = laying_success_yearly
)

summary(success_year)
check_overdispersion(success_year)

```
### Timing

```{r}
timing_yearly_clean <- timing_yearly |>
  filter(year >= 1993)
summary(lm(mean_lay_DOY ~ year, data = timing_yearly_clean))
```

```{r}
str(timing_yearly)
summary(timing_yearly)
```


## Objective 1

```{r}
# Effort Data 

active.nests <- vultures.clean |>
mutate(year = year(ringing.date)) |>
group_by(year) |>
summarise(active_nests = n(), .groups = "drop")

effort_weather <- active.nests |>
left_join(weather_yearly, by = c("year" = "YEAR"))

```


### Year only model 

```{r}
m_year <- glm.nb(active_nests ~ year, data = active.nests)
summary(m_year)
check_overdispersion(m_year)

```

### Autocorrelation in residuals

```{r}
res_effort <- residuals(m_year, type = "pearson")

acf(res_effort,
main = "ACF of residuals: breeding effort (active nests)")

```


### Rainfall 

```{r}
effort_weather <- effort_weather |>
mutate(
z_total_rain = scale(total_rain),
z_max_rain   = scale(max_rain),
z_rain_days  = scale(rain_days)
)

m_rain_only <- glm.nb(
active_nests ~ z_total_rain + z_max_rain + z_rain_days,
data = effort_weather
)
summary(m_rain_only)

```

### Temp 

```{r}
effort_weather <- effort_weather |>
mutate(
z_mean_temp = scale(mean_temp),
z_max_temp  = scale(max_temp),
z_min_temp  = scale(min_temp)
)

max_temp_mod <- glm.nb(
active_nests ~ z_max_temp,
data = effort_weather
)
summary(max_temp_mod)

min_temp_mod <- glm.nb(
active_nests ~ z_min_temp,
data = effort_weather
)
summary(min_temp_mod)

mean_temp_mod <- glm.nb(
active_nests ~ z_mean_temp,
data = effort_weather
)
summary(mean_temp_mod)

```


### Wind 

```{r}
effort_weather <- effort_weather |>
mutate(
z_mean_wind = scale(mean_wind),
z_max_wind  = scale(max_wind)
)

m_wind_only <- glm.nb(
active_nests ~ z_mean_wind + z_max_wind,
data = effort_weather
)
summary(m_wind_only)

```

### Hail 

```{r}
effort_weather <- effort_weather |>
mutate(z_hail_days = scale(hail_days))

m_hail_only <- glm.nb(
active_nests ~ z_hail_days,
data = effort_weather
)
summary(m_hail_only)

```

### Active nests across years 

```{r}
active.nests <- vultures.clean |>
mutate(year = year(ringing.date)) |>
group_by(year) |>
summarise(active_nests = n(), .groups = "drop")

m_year <- glm.nb(active_nests ~ year, data = active.nests)

active.nests_plot <- active.nests |>
mutate(pred_year = predict(m_year, newdata = active.nests, type = "response"))

ggplot(active.nests_plot, aes(x = year, y = active_nests)) +
geom_col(fill = "#89c5d6", alpha = 0.85) +
geom_line(aes(y = pred_year), linewidth = 1.1, colour = "black") +
labs(
x = "Year",
y = "Number of active nests"
) +
theme_bw() +
theme(panel.grid = element_blank())

```

### Effects of max temp on effort

```{r}
effort_weather <- active.nests |>
left_join(weather_yearly, by = c("year" = "YEAR")) |>
mutate(
z_total_rain = as.numeric(scale(total_rain)),
z_max_rain   = as.numeric(scale(max_rain)),
z_rain_days  = as.numeric(scale(rain_days)),
z_mean_temp  = as.numeric(scale(mean_temp)),
z_max_temp   = as.numeric(scale(max_temp)),
z_min_temp   = as.numeric(scale(min_temp)),
z_mean_wind  = as.numeric(scale(mean_wind)),
z_max_wind   = as.numeric(scale(max_wind)),
z_hail_days  = as.numeric(scale(hail_days))
)

m_eff_maxtemp <- glm.nb(
active_nests ~ z_max_temp,
data = effort_weather
)
summary(m_eff_maxtemp)

new_eff_temp <- tibble(
z_max_temp = seq(
min(effort_weather$z_max_temp, na.rm = TRUE),
max(effort_weather$z_max_temp, na.rm = TRUE),
length.out = 100
)
) |>
mutate(
pred_nests = predict(
m_eff_maxtemp,
newdata = cur_data(),
type = "response"
)
)

ggplot(effort_weather, aes(x = z_max_temp, y = active_nests)) +
geom_point(alpha = 0.7) +
geom_line(
data = new_eff_temp,
aes(x = z_max_temp, y = pred_nests),
linewidth = 1.1
) +
labs(
x = "Annual maximum temperature (scaled)",
y = "Number of active nests"
) +
theme_bw() +
theme(panel.grid = element_blank())

```



```{r}
acf(active.nests$active_nests)

```

## Objective 2
### Success DF 

```{r}
failed.nests <- vultures.clean |>
mutate(year = year(ringing.date)) |>
filter(!is.na(year)) |>
group_by(year) |>
summarise(
active_nests  = n(),
success_nests = sum(!is.na(laying.date)),
failed_nests  = active_nests - success_nests,
success_prop  = success_nests / active_nests,
.groups       = "drop"
) |>
filter(active_nests > 0)

```

### Year only model 

```{r}
success_year <- glm(
cbind(success_nests, failed_nests) ~ year,
family = binomial,
data   = failed.nests
)
summary(success_year)
check_overdispersion(success_year)

```

### Rain 

```{r}
success_df <- failed.nests |>
left_join(weather_yearly, by = c("year" = "YEAR")) |>
mutate(
z_total_rain = as.numeric(scale(total_rain)),
z_max_rain   = as.numeric(scale(max_rain)),
z_rain_days  = as.numeric(scale(rain_days))
)

success_rain <- glm(
cbind(success_nests, failed_nests) ~
z_total_rain + z_max_rain + z_rain_days,
family = binomial,
data   = success_df
)
summary(success_rain)
check_overdispersion(success_rain)

```

### Temp 

```{r}
success_df <- success_df |>
mutate(
z_mean_temp = as.numeric(scale(mean_temp)),
z_max_temp  = as.numeric(scale(max_temp)),
z_min_temp  = as.numeric(scale(min_temp))
)

success_minT <- glm(
cbind(success_nests, failed_nests) ~ z_min_temp,
family = binomial,
data   = success_df
)
summary(success_minT)
check_overdispersion(success_minT)

success_maxT <- glm(
cbind(success_nests, failed_nests) ~ z_max_temp,
family = binomial,
data   = success_df
)
summary(success_maxT)
check_overdispersion(success_maxT)

success_meanT <- glm(
cbind(success_nests, failed_nests) ~ z_mean_temp,
family = binomial,
data   = success_df
)
summary(success_meanT)
check_overdispersion(success_meanT)

```

### WInd 

```{r}
success_df <- success_df |>
mutate(
z_mean_wind = as.numeric(scale(mean_wind)),
z_max_wind  = as.numeric(scale(max_wind))
)

m_success_wind <- glm(
cbind(success_nests, failed_nests) ~ z_mean_wind + z_max_wind,
family = binomial,
data   = success_df
)
summary(m_success_wind)
check_overdispersion(m_success_wind)

```

### Hail 

```{r}
success_df <- success_df |>
mutate(
z_hail_days = as.numeric(scale(hail_days))
)

m_success_hail <- glm(
cbind(success_nests, failed_nests) ~ z_hail_days,
family = binomial,
data   = success_df
)
summary(m_success_hail)
check_overdispersion(m_success_hail)

```

## Objective 3

### 60 and 30 day pre laying period 

```{r}
timing_df <- vultures.clean |>
filter(!is.na(laying.date)) |>
mutate(
year    = year(laying.date),
lay_DOY = yday(laying.date)
)

summarise_60 <- function(lay_date, weather) {
w <- weather |>
filter(date > (lay_date - days(60)), date <= lay_date)

tibble(
mean_temp_60  = mean(w$mean_temp, na.rm = TRUE),
max_temp_60   = mean(w$max_temp, na.rm = TRUE),
min_temp_60   = mean(w$min_temp, na.rm = TRUE),
total_rain_60 = sum(w$rain, na.rm = TRUE),
rain_days_60  = sum(w$rain_day, na.rm = TRUE),
mean_wind_60  = mean(w$mean_wind, na.rm = TRUE),
max_wind_60   = mean(w$max_wind, na.rm = TRUE),
hail_days_60  = sum(w$hail, na.rm = TRUE)
)
}

timing_weather_60 <- timing_df |>
mutate(win60 = purrr::map(laying.date, summarise_60, weather = weather_lag)) |>
unnest(win60)

summarise_30 <- function(lay_date, weather) {
  w <- weather |>
    filter(date > (lay_date - days(30)), date <= lay_date)

  tibble(
    mean_temp_30  = mean(w$mean_temp, na.rm = TRUE),
    max_temp_30   = mean(w$max_temp,  na.rm = TRUE),
    min_temp_30   = mean(w$min_temp,  na.rm = TRUE),
    total_rain_30 = sum(w$rain,       na.rm = TRUE),
    rain_days_30  = sum(w$rain_day,   na.rm = TRUE),
    mean_wind_30  = mean(w$mean_wind, na.rm = TRUE),
    max_wind_30   = mean(w$max_wind,  na.rm = TRUE),
    hail_days_30  = sum(w$hail,       na.rm = TRUE)
  )
}

timing_weather_30 <- timing_df |>
  mutate(win30 = purrr::map(laying.date, summarise_30, weather = weather_lag)) |>
  tidyr::unnest(win30)

```

 

--------------------------------------------------------------------------------

## Candidate model set

### Objective 1

```{r}

objective1_table <- tribble(
  ~`Hypothesis / justification`, ~Model,

  # ---- Temperature ----
  "**Temp**", NA,
  "Warmer years increase energetic cost of adult birds, reducing likelihood to breed.",
  "active_nests ~ mean_temp",

  "Extreme heat events cause thermal stress, reducing breeding effort (active cooling is energetically costly and may reduce adult condition).",
  "active_nests ~ max_temp",

  "Cold extremes increase thermoregulatory demand (often increasing time spent foraging), reducing effort put into breeding",
  "active_nests ~ min_temp",

  # ---- Rain ----
  "**Rain**", NA,
  "High rainfall reduces foraging efficiency and adult condition, reducing breeding effort.",
  "active_nests ~ total_rain",

  "Prolonged rainfall conditions reduce breeding effort by limiting foraging opportunity (fewer or weaker thermals for soaring)",
  "active_nests ~ rain_days",

  "Intense rainfall events decrease foraging efficiency and nest attendance, reducing breeding effort.",
  "active_nests ~ max_rain",

  "Previous year’s rainfall influences food availability and adult condition, affecting breeding effort in the following year.",
  "active_nests ~ lag_total_rain",

  # ---- Wind ----
  "**Wind**", NA,
  "Persistent windy conditions increase the cost of flying, limiting foraging and the energy available for reproduction, reducing breeding effort",
  "active_nests ~ mean_wind",

  "Extreme winds increase nest damage risk, reducing the likelihood that adults will attempt breeding (WBV often reuse nests from previous years) ",
  "active_nests ~ max_wind",

  # ---- Hail ----
  "**Hail**", NA,
  "Severe storm events increase disturbance and nest damage risk, reducing breeding effort",
  "active_nests ~ hail_days",

  # ---- Joint Effects ----
  "**Joint effects**", NA,
  "Cold stress combined with prolonged wet conditions jointly limit breeding effort",
  "active_nests ~ min_temp + total_rain",

  "Cold stress combined with intense rainfall events reduces breeding effort",
  "active_nests ~ min_temp + max_rain",

  "Cold extremes combined with extreme wind increase energetic costs and breeding risk, reducing breeding effort",
  "active_nests ~ min_temp + max_wind",

  "Severe storm exposure combined with extreme wind increases nest disturbance, reducing breeding effort",
  "active_nests ~ hail_days + max_wind",

  "Reduced thermals for soaring combined with high flight costs limit breeding effort",
  "active_nests ~ max_rain + max_wind",
  
  "Heat stress combined with prolonged wet conditions jointly reduce breeding effort by increasing energetic costs while limiting foraging",
  "active_nests ~ max_temp + rain_days",
  
 " High annual rainfall and frequent hail events each impose energetic and disturbance costs that reduce breeding effort.",
"active_nests ~ hail_days + rain_days",

  # ---- Interactive Effects ----
  "**Interactive effects**", NA,
  "The negative effect of cold extremes on breeding effort is increased in persistently wet years.",
  "active_nests ~ min_temp * rain_days",

  "Cold-related energetic stress is amplified in windy years due to increased heat loss and flight costs",
  "active_nests ~ min_temp * mean_wind",

  "Adult condition resulting from the previous year interacts with current-year heat stress to influence breeding effort",
  "active_nests ~ lag_total_rain * max_temp"
)

objective1_table_clean <- objective1_table |>
  dplyr::mutate(Model = ifelse(is.na(Model), "", Model))

kable(
  objective1_table_clean,
  align = c("l", "l"),
  caption = "Objective 1 candidate model set for breeding effort (active nests)"
)




```

```{r}
# Annual effort: number of active nests per year
active.nests <- vultures.clean |>
  mutate(year = year(ringing.date)) |>
  group_by(year) |>
  summarise(active_nests = n(), .groups = "drop")


# Join to weather, create log effort response
effort_weather <- active.nests |>
  left_join(weather_yearly_lag, by = c("year" = "YEAR")) |>
  filter(!is.na(lag_total_rain)) |>
  mutate(
    log_active_nests = log(active_nests)
  )

```


```{r}
# checking residuals
par(mfrow = c(1, 2))
```


### Fitingg then no-year models

```{r}
# Baseline 
m_null <- lm(log_active_nests ~ 1, data = effort_weather)

# Single predictor models 
m_mean_temp      <- lm(log_active_nests ~ mean_temp,      data = effort_weather)
m_max_temp       <- lm(log_active_nests ~ max_temp,       data = effort_weather)
m_min_temp       <- lm(log_active_nests ~ min_temp,       data = effort_weather)

m_total_rain     <- lm(log_active_nests ~ total_rain,     data = effort_weather)
m_rain_days      <- lm(log_active_nests ~ rain_days,      data = effort_weather)
m_max_rain       <- lm(log_active_nests ~ max_rain,       data = effort_weather)
m_lag_total_rain <- lm(log_active_nests ~ lag_total_rain, data = effort_weather)

m_mean_wind      <- lm(log_active_nests ~ mean_wind,      data = effort_weather)
m_max_wind       <- lm(log_active_nests ~ max_wind,       data = effort_weather)
m_hail_days      <- lm(log_active_nests ~ hail_days,      data = effort_weather)

# Joint effects 
m_minT_totalR    <- lm(log_active_nests ~ min_temp + total_rain,  data = effort_weather)
m_minT_maxR      <- lm(log_active_nests ~ min_temp + max_rain,    data = effort_weather)
m_minT_maxW      <- lm(log_active_nests ~ min_temp + max_wind,    data = effort_weather)
m_hail_maxW      <- lm(log_active_nests ~ hail_days + max_wind,   data = effort_weather)
m_maxR_maxW      <- lm(log_active_nests ~ max_rain + max_wind,    data = effort_weather)
m_maxT_rainDays  <- lm(log_active_nests ~ max_temp + rain_days,   data = effort_weather)
m_hail_rainDays  <- lm(log_active_nests ~ hail_days + rain_days,  data = effort_weather)

# Interactions 
m_minT_x_rainDays <- lm(log_active_nests ~ min_temp * rain_days,      data = effort_weather)
m_minT_x_meanWind <- lm(log_active_nests ~ min_temp * mean_wind,      data = effort_weather)
m_lagR_x_maxT     <- lm(log_active_nests ~ lag_total_rain * max_temp, data = effort_weather)
```

### Fit with year models 

```{r}
# Baseline 
m_year <- lm(log_active_nests ~ year, data = effort_weather)

# Single predictor models 
m_mean_temp_year      <- lm(log_active_nests ~ year + mean_temp,      data = effort_weather)
m_max_temp_year       <- lm(log_active_nests ~ year + max_temp,       data = effort_weather)
m_min_temp_year       <- lm(log_active_nests ~ year + min_temp,       data = effort_weather)

m_total_rain_year     <- lm(log_active_nests ~ year + total_rain,     data = effort_weather)
m_rain_days_year      <- lm(log_active_nests ~ year + rain_days,      data = effort_weather)
m_max_rain_year       <- lm(log_active_nests ~ year + max_rain,       data = effort_weather)
m_lag_total_rain_year <- lm(log_active_nests ~ year + lag_total_rain, data = effort_weather)

m_mean_wind_year      <- lm(log_active_nests ~ year + mean_wind,      data = effort_weather)
m_max_wind_year       <- lm(log_active_nests ~ year + max_wind,       data = effort_weather)
m_hail_days_year      <- lm(log_active_nests ~ year + hail_days,      data = effort_weather)

# Joint effects 
m_minT_totalR_year    <- lm(log_active_nests ~ year + min_temp + total_rain, data = effort_weather)
m_minT_maxR_year      <- lm(log_active_nests ~ year + min_temp + max_rain,   data = effort_weather)
m_minT_maxW_year      <- lm(log_active_nests ~ year + min_temp + max_wind,   data = effort_weather)
m_hail_maxW_year      <- lm(log_active_nests ~ year + hail_days + max_wind,  data = effort_weather)
m_maxR_maxW_year      <- lm(log_active_nests ~ year + max_rain + max_wind,   data = effort_weather)
m_maxT_rainDays_year  <- lm(log_active_nests ~ year + max_temp + rain_days,  data = effort_weather)
m_hail_rainDays_year  <- lm(log_active_nests ~ year + hail_days + rain_days, data = effort_weather)

# Interactions 
m_minT_x_rainDays_year <- lm(log_active_nests ~ year + min_temp * rain_days,      data = effort_weather)
m_minT_x_meanWind_year <- lm(log_active_nests ~ year + min_temp * mean_wind,      data = effort_weather)
m_lagR_x_maxT_year     <- lm(log_active_nests ~ year + lag_total_rain * max_temp, data = effort_weather)
```



---

Two separate AICc model selection runs

```{r}
# AIC 1: without year
cand_effort_no_year <- list(
  null            = m_null,

  mean_temp       = m_mean_temp,
  max_temp        = m_max_temp,
  min_temp        = m_min_temp,
  total_rain      = m_total_rain,
  rain_days       = m_rain_days,
  max_rain        = m_max_rain,
  lag_total_rain  = m_lag_total_rain,
  mean_wind       = m_mean_wind,
  max_wind        = m_max_wind,
  hail_days       = m_hail_days,

  minT_totalR     = m_minT_totalR,
  minT_maxR       = m_minT_maxR,
  minT_maxW       = m_minT_maxW,
  hail_maxW       = m_hail_maxW,
  maxR_maxW       = m_maxR_maxW,
  maxT_rainDays   = m_maxT_rainDays,
  hail_rainDays   = m_hail_rainDays,

  minT_x_rainDays = m_minT_x_rainDays,
  minT_x_meanWind = m_minT_x_meanWind,
  lagR_x_maxT     = m_lagR_x_maxT
)

aic_effort_no_year <- aictab(cand.set = cand_effort_no_year, modnames = names(cand_effort_no_year))
aic_effort_no_year
```

```{r}
# AIC 2: with year
cand_effort_with_year <- list(
  year               = m_year,

  mean_temp          = m_mean_temp_year,
  max_temp           = m_max_temp_year,
  min_temp           = m_min_temp_year,
  total_rain         = m_total_rain_year,
  rain_days          = m_rain_days_year,
  max_rain           = m_max_rain_year,
  lag_total_rain     = m_lag_total_rain_year,
  mean_wind          = m_mean_wind_year,
  max_wind           = m_max_wind_year,
  hail_days          = m_hail_days_year,

  minT_totalR        = m_minT_totalR_year,
  minT_maxR          = m_minT_maxR_year,
  minT_maxW          = m_minT_maxW_year,
  hail_maxW          = m_hail_maxW_year,
  maxR_maxW          = m_maxR_maxW_year,
  maxT_rainDays      = m_maxT_rainDays_year,
  hail_rainDays      = m_hail_rainDays_year,

  minT_x_rainDays    = m_minT_x_rainDays_year,
  minT_x_meanWind    = m_minT_x_meanWind_year,
  lagR_x_maxT        = m_lagR_x_maxT_year
)

aic_effort_with_year <- aictab(cand.set = cand_effort_with_year, modnames = names(cand_effort_with_year))
aic_effort_with_year

```

### Check residuals

```{r}
# identify top-ranked model (no year)
best_no_year_name <- aic_effort_no_year$Modnames[1]
best_no_year_E <- cand_effort_no_year[[best_no_year_name]]

par(mfrow = c(2,2))
plot(best_no_year_E)

# identify top-ranked model (with year)
best_with_year_name <- aic_effort_with_year$Modnames[1]
best_with_year_E <- cand_effort_with_year[[best_with_year_name]]

par(mfrow = c(2,2))
plot(best_with_year_E)

```

```{r}
# year-only baseline and best with-year model
summary(m_year)$adj.r.squared
summary(best_with_year_E)$adj.r.squared

# best no-year model
summary(best_no_year_E)$adj.r.squared
```

### Figures 

```{r}
ggplot(effort_weather, aes(x = year, y = active_nests)) +
  geom_point(
    size = 2.4,
    colour = "#B1BD8C",
    alpha = 0.9
  ) +
  geom_smooth(
    method = "lm",
    se = TRUE,
    colour = "#D5D6D2",
    fill   = "#D5D6D2",
    alpha  = 0.25,
    linewidth = 1.8
  ) +
  scale_x_continuous(
    breaks = seq(
      min(effort_weather$year),
      max(effort_weather$year),
      by = 5
    )
  ) +
  labs(
    x = "Year",
    y = "Number of active nests"
  ) +
  theme_bw(base_family = "Times New Roman") +
  theme(
    panel.grid = element_blank(),
    axis.title = element_text(face = "bold", size = 12),
    axis.text  = element_text(face = "bold", size = 10)
  )


```




```{r}

prep_aic_plot <- function(aic_obj, set_label){
  df <- as.data.frame(aic_obj)

  # model names
  if ("Modnames" %in% names(df)) df$model <- df$Modnames
  if (!"model" %in% names(df)) df$model <- rownames(df)

  df |>
    dplyr::mutate(set = set_label) |>
    dplyr::rename(delta = Delta_AICc, weight = AICcWt) |>
    dplyr::select(set, model, delta, weight)
}

aic_plot_df <- dplyr::bind_rows(
  prep_aic_plot(aic_effort_with_year, "With year"),
  prep_aic_plot(aic_effort_no_year, "Without year")
) |>
  dplyr::filter(delta <= 3) |>
  dplyr::group_by(set) |>
  dplyr::mutate(model = forcats::fct_reorder(model, -delta)) |>
  dplyr::ungroup()

ggplot(aic_plot_df, aes(x = delta, y = model)) +
  geom_vline(xintercept = 2, linetype = 2) +
  geom_point(aes(size = weight), colour = "grey20") +
  facet_wrap(~set, scales = "free_y") +
  scale_size_continuous(range = c(2, 8)) +
  labs(
    x = expression(Delta*"AICc (lower is better)"),
    y = NULL,
    title = "Support for candidate models with and without year",
    subtitle = "Only models with ΔAICc ≤ 3 are shown; point size indicates AICc weight"
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())
 
```

```{r}
library(dplyr)
library(ggplot2)
library(forcats)

plot_aic_facets_from_cands <- function(cand_with, cand_without,
                                       label_with = "With year",
                                       label_without = "Without year",
                                       daic_max = 3){

  build_df <- function(cand_list, panel_label){
    tibble(
      model_id = names(cand_list),
      AICc = sapply(cand_list, AICcmodavg::AICc)
    ) |>
      arrange(AICc) |>
      mutate(
        dAICc = AICc - min(AICc),
        weight = exp(-0.5 * dAICc) / sum(exp(-0.5 * dAICc)),
        panel = panel_label
      )
  }

  dat <- bind_rows(
    build_df(cand_with,    label_with),
    build_df(cand_without, label_without)
  ) |>
    filter(is.finite(dAICc), dAICc <= daic_max) |>
    group_by(panel) |>
    arrange(dAICc, .by_group = TRUE) |>
    mutate(model_id = fct_reorder(model_id, dAICc, .desc = TRUE)) |>
    ungroup()

  ggplot(dat, aes(x = dAICc, y = model_id, size = weight)) +
    geom_vline(xintercept = 2, linetype = "dashed") +
    geom_point(alpha = 0.9) +
    facet_wrap(~panel, scales = "free_y") +
    labs(
      x = expression(Delta*AIC[c]*" (lower is better)"),
      y = NULL,
      size = "AICc weight",
      title = "Support for candidate models with and without year",
      subtitle = paste0("Only models with ΔAICc ≤ ", daic_max,
                        " are shown; dashed line = ΔAICc = 2")
    ) +
    theme_bw() +
    theme(
      panel.grid = element_blank(),
      legend.position = "right"
    )
}

```

```{r}

# Table 1 (weather-only)

library(dplyr)
library(tibble)

aic_df <- as.data.frame(aic_effort_no_year)

# model ids
if ("Modnames" %in% names(aic_df)) {
  aic_df <- aic_df |> dplyr::mutate(model_id = Modnames)
} else {
  aic_df <- tibble::rownames_to_column(aic_df, "model_id")
}

table1 <- aic_df |>
  dplyr::rename(
    `ΔAICc` = Delta_AICc,
    w       = AICcWt
  ) |>
  dplyr::select(model_id, K, AICc, `ΔAICc`, w) |>
  dplyr::arrange(`ΔAICc`)

get_stats <- function(mod){
  adjr2 <- summary(mod)$adj.r.squared
  if (length(coef(mod)) == 2) {
    cf <- summary(mod)$coefficients
    slope_se <- paste0(round(cf[2,1], 3), " (", round(cf[2,2], 3), ")")
  } else {
    slope_se <- ""
  }
  tibble::tibble(`Adj. R²` = adjr2, `slope (SE)` = slope_se)
}

stats_df <- lapply(table1$model_id, function(mn) get_stats(cand_effort_no_year[[mn]])) |>
  dplyr::bind_rows() |>
  dplyr::mutate(model_id = table1$model_id)

table1 <- table1 |>
  dplyr::left_join(stats_df, by = "model_id") |>
  dplyr::mutate(
    AICc = round(AICc, 2),
    `ΔAICc` = round(`ΔAICc`, 2),
    w = round(w, 3),
    `Adj. R²` = round(`Adj. R²`, 3)
  )

# grouping and neat names
group_order <- c("Baseline","Rain","Temperature","Wind","Hail","Joint effects","Interactions")

model_group <- function(m){
  dplyr::case_when(
    m == "null" ~ "Baseline",
    m %in% c("total_rain","rain_days","max_rain","lag_total_rain") ~ "Rain",
    m %in% c("mean_temp","max_temp","min_temp") ~ "Temperature",
    m %in% c("mean_wind","max_wind") ~ "Wind",
    m %in% c("hail_days") ~ "Hail",
    m %in% c("minT_totalR","minT_maxR","minT_maxW","hail_maxW","maxR_maxW","maxT_rainDays","hail_rainDays") ~ "Joint effects",
    m %in% c("minT_x_rainDays","minT_x_meanWind","lagR_x_maxT") ~ "Interactions",
    TRUE ~ "Joint effects"
  )
}

pretty_model <- function(x){
  dplyr::recode(
    x,
    "null"            = "Intercept only",
    "total_rain"      = "Total rainfall",
    "rain_days"       = "Rainy days",
    "max_rain"        = "Maximum daily rainfall",
    "lag_total_rain"  = "Previous year's total rainfall",
    "mean_temp"       = "Mean temperature",
    "max_temp"        = "Maximum temperature",
    "min_temp"        = "Minimum temperature",
    "mean_wind"       = "Mean wind speed",
    "max_wind"        = "Maximum wind speed",
    "hail_days"       = "Hail days",
    "minT_totalR"     = "Min temperature + total rainfall",
    "minT_maxR"       = "Min temperature + max daily rainfall",
    "minT_maxW"       = "Min temperature + max wind speed",
    "hail_maxW"       = "Hail days + max wind speed",
    "maxR_maxW"       = "Max daily rainfall + max wind speed",
    "maxT_rainDays"   = "Max temperature + rainy days",
    "hail_rainDays"   = "Hail days + rainy days",
    "minT_x_rainDays" = "Min temperature × rainy days",
    "minT_x_meanWind" = "Min temperature × mean wind speed",
    "lagR_x_maxT"     = "Prev. rainfall × max temperature",
    .default = x
  )
}

table1_clean <- table1 |>
  dplyr::mutate(
    Group = model_group(model_id),
    Model = pretty_model(model_id),
    Group = factor(Group, levels = group_order)
  ) |>
  dplyr::arrange(Group, `ΔAICc`) |>
  dplyr::select(Group, Model, K, AICc, `ΔAICc`, w, `Adj. R²`, `slope (SE)`)

# print (kable + pack_rows)
group_sizes <- table1_clean |>
  dplyr::count(Group, name = "n") |>
  dplyr::mutate(
    start = cumsum(dplyr::lag(n, default = 0)) + 1,
    end   = cumsum(n)
  )

tbl <- knitr::kable(
  table1_clean |> dplyr::select(-Group),
  caption = "Table 1. Weather-only candidate models explaining annual breeding effort (log number of active nests) at Dronfield. K = number of parameters; AICc = small-sample AIC; ΔAICc = difference from the best model; w = Akaike weight. Adjusted R² is shown for all models; slope (SE) is reported only for single-predictor models.",
  align = "l"
) |>
  kableExtra::kable_styling(full_width = FALSE)

for (i in seq_len(nrow(group_sizes))) {
  tbl <- tbl |>
    kableExtra::pack_rows(
      as.character(group_sizes$Group[i]),
      group_sizes$start[i],
      group_sizes$end[i]
    )
}

tbl

```

```{r}
# Table 2 (with year)

library(dplyr)
library(tibble)
library(knitr)
library(kableExtra)

aic_df <- as.data.frame(aic_effort_with_year)

# model ids
if ("Modnames" %in% names(aic_df)) {
  aic_df <- aic_df |> dplyr::mutate(model_id = Modnames)
} else {
  aic_df <- tibble::rownames_to_column(aic_df, "model_id")
}

table2 <- aic_df |>
  dplyr::rename(
    `ΔAICc` = Delta_AICc,
    w       = AICcWt
  ) |>
  dplyr::select(model_id, K, AICc, `ΔAICc`, w) |>
  dplyr::arrange(`ΔAICc`)

# define which model_ids are "single weather predictor" models
single_weather_models <- c(
  "total_rain","rain_days","max_rain","lag_total_rain",
  "mean_temp","max_temp","min_temp",
  "mean_wind","max_wind",
  "hail_days"
)

get_stats_with_year <- function(mod, model_id){

  s <- summary(mod)
  adjr2 <- s$adj.r.squared
  slope_se <- ""

  # only fill slope for the single-weather models (NOT baseline year, NOT multi-term)
  if (model_id %in% single_weather_models) {

    # coefficient names in the fitted lm
    cn <- names(coef(mod))
    cn <- setdiff(cn, "(Intercept)")

    # REMOVE the year term(s) so we only keep the weather predictor
    # (covers year, poly(year,2), scale(year), etc.)
    cn_weather <- cn[!grepl("^year$|^year\\b|\\byear\\b", cn)]

    # if exactly 1 term remains, that's our weather slope
    if (length(cn_weather) == 1) {
      term <- cn_weather[1]
      est <- coef(mod)[term]
      se  <- sqrt(diag(vcov(mod)))[term]

      slope_se <- paste0(
        round(est, 3),
        " (",
        round(se, 3),
        ")"
      )
    } else {
      slope_se <- ""
    }
  }

  tibble::tibble(`Adj. R²` = adjr2, `slope (SE)` = slope_se)
}

# IMPORTANT: candidate model list must be named cand_effort_with_year
stats_df <- lapply(table2$model_id, function(mn)
  get_stats_with_year(cand_effort_with_year[[mn]], mn)
) |>
  dplyr::bind_rows() |>
  dplyr::mutate(model_id = table2$model_id)

table2 <- table2 |>
  dplyr::left_join(stats_df, by = "model_id") |>
  dplyr::mutate(
    AICc = round(AICc, 2),
    `ΔAICc` = round(`ΔAICc`, 2),
    w = round(w, 3),
    `Adj. R²` = round(`Adj. R²`, 3)
  )

# grouping and neat names
group_order <- c("Baseline","Rain","Temperature","Wind","Hail","Joint effects","Interactions")

model_group_with_year <- function(m){
  dplyr::case_when(
    m == "year" ~ "Baseline",
    m %in% c("total_rain","rain_days","max_rain","lag_total_rain") ~ "Rain",
    m %in% c("mean_temp","max_temp","min_temp") ~ "Temperature",
    m %in% c("mean_wind","max_wind") ~ "Wind",
    m %in% c("hail_days") ~ "Hail",
    m %in% c("minT_totalR","minT_maxR","minT_maxW","hail_maxW","maxR_maxW","maxT_rainDays","hail_rainDays") ~ "Joint effects",
    m %in% c("minT_x_rainDays","minT_x_meanWind","lagR_x_maxT") ~ "Interactions",
    TRUE ~ "Joint effects"
  )
}

pretty_model_with_year <- function(x){
  dplyr::recode(
    x,
    "year"            = "Year (baseline)",
    "total_rain"      = "Total rainfall",
    "rain_days"       = "Rainy days",
    "max_rain"        = "Maximum daily rainfall",
    "lag_total_rain"  = "Previous year's total rainfall",
    "mean_temp"       = "Mean temperature",
    "max_temp"        = "Maximum temperature",
    "min_temp"        = "Minimum temperature",
    "mean_wind"       = "Mean wind speed",
    "max_wind"        = "Maximum wind speed",
    "hail_days"       = "Hail days",
    "minT_totalR"     = "Min temperature + total rainfall",
    "minT_maxR"       = "Min temperature + max daily rainfall",
    "minT_maxW"       = "Min temperature + max wind speed",
    "hail_maxW"       = "Hail days + max wind speed",
    "maxR_maxW"       = "Max daily rainfall + max wind speed",
    "maxT_rainDays"   = "Max temperature + rainy days",
    "hail_rainDays"   = "Hail days + rainy days",
    "minT_x_rainDays" = "Min temperature × rainy days",
    "minT_x_meanWind" = "Min temperature × mean wind speed",
    "lagR_x_maxT"     = "Prev. rainfall × max temperature",
    .default = x
  )
}

table2_clean <- table2 |>
  dplyr::mutate(
    Group = model_group_with_year(model_id),
    Model = pretty_model_with_year(model_id),
    Group = factor(Group, levels = group_order)
  ) |>
  dplyr::arrange(Group, `ΔAICc`) |>
  dplyr::select(Group, Model, K, AICc, `ΔAICc`, w, `Adj. R²`, `slope (SE)`)

# print (kable + pack_rows) — NO CAPTION
group_sizes <- table2_clean |>
  dplyr::count(Group, name = "n") |>
  dplyr::mutate(
    start = cumsum(dplyr::lag(n, default = 0)) + 1,
    end   = cumsum(n)
  )

tbl2 <- knitr::kable(
  table2_clean |> dplyr::select(-Group),
  align = "l"
) |>
  kableExtra::kable_styling(full_width = FALSE, position = "left")

for (i in seq_len(nrow(group_sizes))) {
  tbl2 <- tbl2 |>
    kableExtra::pack_rows(
      as.character(group_sizes$Group[i]),
      group_sizes$start[i],
      group_sizes$end[i]
    )
}

tbl2


```

### TABLE 1: (a) WITH AND (b) WITHOUT YEAR

```{r}
library(dplyr)
library(tibble)
library(officer)
library(flextable)

stopifnot(exists("aic_effort_with_year"))
stopifnot(exists("cand_effort_with_year"))
stopifnot(exists("aic_effort_no_year"))
stopifnot(exists("cand_effort_no_year"))



# -------------------------
# 0) shared bits
# -------------------------
group_order <- c("Baseline","Rain","Temperature","Wind","Hail","Joint effects","Interactions")

model_group <- function(m){
  dplyr::case_when(
    m %in% c("null", "year") ~ "Baseline",
    m %in% c("total_rain","rain_days","max_rain","lag_total_rain") ~ "Rain",
    m %in% c("mean_temp","max_temp","min_temp") ~ "Temperature",
    m %in% c("mean_wind","max_wind") ~ "Wind",
    m %in% c("hail_days") ~ "Hail",
    m %in% c("minT_totalR","minT_maxR","minT_maxW","hail_maxW","maxR_maxW","maxT_rainDays","hail_rainDays") ~ "Joint effects",
    m %in% c("minT_x_rainDays","minT_x_meanWind","lagR_x_maxT") ~ "Interactions",
    TRUE ~ "Joint effects"
  )
}

pretty_model <- function(x){
  dplyr::recode(
    x,
    "null"            = "Intercept only",
    "year"            = "Year (baseline)",
    "total_rain"      = "Total rainfall",
    "rain_days"       = "Rainy days",
    "max_rain"        = "Maximum daily rainfall",
    "lag_total_rain"  = "Previous year's total rainfall",
    "mean_temp"       = "Mean temperature",
    "max_temp"        = "Maximum temperature",
    "min_temp"        = "Minimum temperature",
    "mean_wind"       = "Mean wind speed",
    "max_wind"        = "Maximum wind speed",
    "hail_days"       = "Hail days",
    "minT_totalR"     = "Min temperature + total rainfall",
    "minT_maxR"       = "Min temperature + max daily rainfall",
    "minT_maxW"       = "Min temperature + max wind speed",
    "hail_maxW"       = "Hail days + max wind speed",
    "maxR_maxW"       = "Max daily rainfall + max wind speed",
    "maxT_rainDays"   = "Max temperature + rainy days",
    "hail_rainDays"   = "Hail days + rainy days",
    "minT_x_rainDays" = "Min temperature × rainy days",
    "minT_x_meanWind" = "Min temperature × mean wind speed",
    "lagR_x_maxT"     = "Prev. rainfall × max temperature",
    .default = x
  )
}

single_weather_models <- c( 
  "total_rain","rain_days","max_rain","lag_total_rain",
  "mean_temp","max_temp","min_temp",
  "mean_wind","max_wind",
  "hail_days"
)

# Deviance: -2*logLik (as requested)
get_dev_ll <- function(mod){
  as.numeric(-2 * stats::logLik(mod))
}

# slope (SE) only for single predictor weather models
get_slope_se_single_weather <- function(mod, model_id){
  slope_se <- ""
  if (model_id %in% single_weather_models) {
    cn <- names(coef(mod))
    cn <- setdiff(cn, "(Intercept)")
    cn_weather <- cn[!grepl("^year$|^year\\b|\\byear\\b", cn)]
    if (length(cn_weather) == 1) {
      term <- cn_weather[1]
      est <- coef(mod)[term]
      se  <- sqrt(diag(vcov(mod)))[term]
      slope_se <- paste0(round(est, 3), " (", round(se, 3), ")")
    }
  }
  slope_se
}

# -------------------------
# helper: prep AIC set + recompute ΔAICc and w WITHIN set
# -------------------------
prep_aic_set <- function(aic_obj){
  aic_df <- as.data.frame(aic_obj)

  if ("Modnames" %in% names(aic_df)) {
    aic_df <- aic_df %>% mutate(model_id = Modnames)
  } else {
    aic_df <- tibble::rownames_to_column(aic_df, "model_id")
  }

  if (!("AICc" %in% names(aic_df))) stop("Could not find an AICc column in the AIC table.")

  if (!("K" %in% names(aic_df))) {
    if ("k" %in% names(aic_df)) aic_df$K <- aic_df$k
    if ("df" %in% names(aic_df)) aic_df$K <- aic_df$df
  }
  if (!("K" %in% names(aic_df))) stop("Could not find K (number of parameters) in the AIC table.")

  aic_df %>%
    mutate(
      AICc = as.numeric(AICc),
      `ΔAICc` = AICc - min(AICc, na.rm = TRUE),
      w = {
        rel <- exp(-0.5 * (AICc - min(AICc, na.rm = TRUE)))
        rel / sum(rel, na.rm = TRUE)
      }
    ) %>%
    select(model_id, K, AICc, `ΔAICc`, w) %>%
    arrange(`ΔAICc`)
}

# -------------------------
# helper: build table DF for a set (keeps Group for header-building)
# -------------------------
build_df <- function(tab, cand_list){
  tab %>%
    mutate(
      Deviance = sapply(model_id, function(mn) get_dev_ll(cand_list[[mn]])),
      `R²`     = sapply(model_id, function(mn) summary(cand_list[[mn]])$r.squared),
      `slope (SE)` = sapply(model_id, function(mn) get_slope_se_single_weather(cand_list[[mn]], mn)),
      Group = factor(model_group(model_id), levels = group_order),
      Model = pretty_model(model_id),
      K = as.integer(K)
    ) %>%
    mutate(
      Deviance = round(Deviance, 2),
      AICc     = round(AICc, 2),
      `ΔAICc`  = round(`ΔAICc`, 2),
      w        = round(w, 3),
      `R²`     = round(`R²`, 3)
    ) %>%
    arrange(Group, `ΔAICc`) %>%
    select(Group, Model, K, Deviance, AICc, `ΔAICc`, w, `R²`, `slope (SE)`)
}

# -------------------------
# helper: insert TREND + GROUP header rows and return (df_print, row indices)
# -------------------------
add_headers <- function(df, trend_label){
  df <- df %>% mutate(Group = factor(Group, levels = group_order))

  groups_here <- levels(droplevels(df$Group))
  groups_here <- groups_here[groups_here %in% unique(as.character(df$Group))]

  empty_row <- df[0, ]

  trend_row <- empty_row
  trend_row[1, ] <- NA
  trend_row$Group <- NA
  trend_row$Model <- trend_label

  out <- trend_row
  is_trend <- TRUE
  is_group <- FALSE

  for (g in groups_here) {
    gh <- empty_row
    gh[1, ] <- NA
    gh$Group <- NA
    gh$Model <- g

    rows_g <- df %>% filter(as.character(Group) == g) %>% mutate(Group = NA)

    out <- bind_rows(out, gh, rows_g)
    is_trend <- c(is_trend, FALSE, rep(FALSE, nrow(rows_g)))
    is_group <- c(is_group, TRUE,  rep(FALSE, nrow(rows_g)))
  }

  df_print <- out %>% select(-Group)
  df_print[is.na(df_print)] <- ""

  list(
    df_print = df_print,
    trend_rows = which(is_trend),
    group_rows = which(is_group)
  )
}

# -------------------------
# Build Table 1a and 1b data
# -------------------------
tab_wy <- prep_aic_set(aic_effort_with_year)
tab_ny <- prep_aic_set(aic_effort_no_year)

df_wy <- build_df(tab_wy, cand_effort_with_year)
df_ny <- build_df(tab_ny, cand_effort_no_year)

hdr_wy <- add_headers(df_wy, "a) Models including year trend")
hdr_ny <- add_headers(df_ny, "b) Models without year trend")

df_print_1a <- hdr_wy$df_print
df_print_1b <- hdr_ny$df_print

# -------------------------
# Flextable styling (matching your old grey header-row look)
# -------------------------
make_ft <- function(df_print, trend_rows, group_rows){

  ft <- flextable(df_print) %>%
    font(fontname = "Times New Roman", part = "all") %>%
    fontsize(size = 12, part = "all") %>%
    bold(part = "header") %>%
    bg(part = "header", bg = "#f2f2f2") %>%
    align(j = 1, align = "left", part = "all") %>%
    align(j = 2:ncol(df_print), align = "center", part = "all") %>%
    # Trend row (darker)
    bg(i = trend_rows, bg = "#d9d9d9", part = "body") %>%
    bold(i = trend_rows, part = "body") %>%
    # Group rows (lighter)
    bg(i = group_rows, bg = "#e6e6e6", part = "body") %>%
    bold(i = group_rows, part = "body") %>%
    autofit()

  # Underline the TREND header text in column 1 (and keep it bold)
  ft <- compose(
    ft,
    i = trend_rows,
    j = 1,
    part = "body",
    value = as_paragraph(
      as_chunk(
        df_print[trend_rows, 1],
        props = fp_text(underline = TRUE, bold = TRUE)
      )
    )
  )

  ft
}

ft_1a <- make_ft(df_print_1a, hdr_wy$trend_rows, hdr_wy$group_rows)
ft_1b <- make_ft(df_print_1b, hdr_ny$trend_rows, hdr_ny$group_rows)

# -------------------------
# Captions (updated to R², separate ΔAICc within each set)
# -------------------------
caption_1a <- paste0(
  "Table 1a. Model selection results relating to annual weather variation and the number of active nests at Dronfield (1993–2024) for models including a linear year effect (corresponding to Fig. 1a). ",
  "Models were fitted using linear regressions. A '+' indicates additive effects and '×' indicates an interaction. ",
  "K is the number of parameters; AICc is Akaike's Information Criterion; ΔAICc is relative to the best model within this model set; w is the Akaike weight; R² is variance explained. ",
  "Slopes (SE) are reported for simple predictor models only."
)

caption_1b <- paste0(
  "Table 1b. Model selection results relating to annual weather variation and the number of active nests at Dronfield (1993–2024) for models excluding a linear year effect (corresponding to Figs. 1b–c). ",
  "Models were fitted using linear regressions. A '+' indicates additive effects and '×' indicates an interaction. ",
  "K is the number of parameters; AICc is Akaike's Information Criterion; ΔAICc is relative to the best model within this model set; w is the Akaike weight; R² is variance explained. ",
  "Slopes (SE) are reported for simple predictor models only."
)

# -------------------------
# Export BOTH tables to one Word doc
# -------------------------
doc <- read_docx() %>%
  body_add_par(caption_1a, style = "Normal") %>%
  body_add_par("", style = "Normal") %>%
  body_add_flextable(ft_1a) %>%
  body_add_par("", style = "Normal") %>%
  body_add_par(caption_1b, style = "Normal") %>%
  body_add_par("", style = "Normal") %>%
  body_add_flextable(ft_1b)

print(doc, target = "Table_1a_1b_Active_Nests.docx")

```


```{r}
mods4 <- c("mean_temp", "rain_days", "max_wind", "max_rain")  # change these 4

# WITH year set
ll_with_year <- sapply(mods4, function(m) logLik(cand_effort_with_year[[m]]))
ll_with_year

# convert to -2*logLik (what your supervisor calls deviance)
dev_with_year <- sapply(mods4, function(m) as.numeric(-2 * logLik(cand_effort_with_year[[m]])))
dev_with_year
```




```{r}
library(dplyr)
library(ggplot2)
library(tidytext)

aic_no_year_plot <- table1_clean |>
  filter(Group != "Baseline" | Model == "Intercept only") |>
  mutate(
    Model_f = reorder_within(Model, `ΔAICc`, Group),
    is_null = Model == "Intercept only"
  )

ggplot(aic_no_year_plot, aes(x = `ΔAICc`, y = Model_f)) +
  geom_vline(xintercept = 2, linetype = "dashed", colour = "grey40") +
  geom_point(aes(size = w, shape = is_null), alpha = 0.85) +
  scale_shape_manual(values = c(`FALSE` = 16, `TRUE` = 17), guide = "none") +
  scale_y_reordered() +
  scale_size_continuous(range = c(2.5, 7)) +
  labs(
    x = expression(Delta*AIC[c]),
    y = NULL,
    size = "Akaike weight",
    title = "Weather-only model support (year excluded)"
  ) +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    axis.text.y = element_text(size = 10)
  )

```

```{r}
library(dplyr)
library(ggplot2)
library(tidytext)


aic_with_year_plot <- as.data.frame(aic_effort_with_year) |>
  tibble::rownames_to_column("model_id") |>
  dplyr::rename(
    `ΔAICc` = Delta_AICc,
    w = AICcWt
  ) |>
  dplyr::mutate(
    Model = pretty_model(model_id),
    Model_f = reorder(Model, `ΔAICc`),
    is_null = model_id == "null"
  )

ggplot(aic_with_year_plot, aes(x = `ΔAICc`, y = Model_f)) +
  geom_vline(xintercept = 2, linetype = "dashed", colour = "grey40") +
  geom_point(aes(size = w, shape = is_null), alpha = 0.85) +
  scale_shape_manual(values = c(`FALSE` = 16, `TRUE` = 17), guide = "none") +
  scale_size_continuous(range = c(2.5, 7)) +
  labs(
    x = expression(Delta*AIC[c]),
    y = NULL,
    size = "Akaike weight",
    title = "Weather + year model support"
  ) +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    axis.text.y = element_text(size = 10)
  )

```


```{r}
library(dplyr)

model_group_with_year <- function(m){

  dplyr::case_when(
    m %in% c("year") ~ "Baseline",

    m %in% c("total_rain","rain_days","max_rain","lag_total_rain") ~ "Rain",

    m %in% c("mean_temp","max_temp","min_temp") ~ "Temperature",

    m %in% c("mean_wind","max_wind") ~ "Wind",

    m %in% c("hail_days") ~ "Hail",

    m %in% c(
      "minT_totalR","minT_maxR","minT_maxW","hail_maxW","maxR_maxW",
      "maxT_rainDays","hail_rainDays","maxT_maxR","minT_rainDays"
    ) ~ "Joint effects",

    m %in% c(
      "minT_totalR_x","minT_maxR_x","minT_maxW_x","hail_maxW_x","maxR_maxW_x",
      "maxT_rainDays_x","hail_rainDays_x","maxT_maxR_x","minT_rainDays_x"
    ) ~ "Interactions",

    TRUE ~ "Other"
  )
}

```

```{r}
library(dplyr)
library(tibble)
library(officer)
library(flextable)



aic_df <- as.data.frame(aic_effort_no_year)

# model ids
if ("Modnames" %in% names(aic_df)) {
  aic_df <- aic_df |> dplyr::mutate(model_id = Modnames)
} else {
  aic_df <- tibble::rownames_to_column(aic_df, "model_id")
}

table1 <- aic_df |>
  dplyr::rename(
    `ΔAICc` = Delta_AICc,
    w = AICcWt
  ) |>
  dplyr::select(model_id, K, AICc, `ΔAICc`, w) |>
  dplyr::arrange(`ΔAICc`)


get_stats <- function(mod){
  adjr2 <- summary(mod)$adj.r.squared
  if (length(coef(mod)) == 2) {
    cf <- summary(mod)$coefficients
    slope_se <- paste0(round(cf[2,1], 3), " (", round(cf[2,2], 3), ")")
  } else {
    slope_se <- ""
  }
  tibble::tibble(`Adj. R²` = adjr2, `slope (SE)` = slope_se)
}

stats_df <- lapply(table1$model_id, function(mn) get_stats(cand_effort_no_year[[mn]])) |>
  dplyr::bind_rows() |>
  dplyr::mutate(model_id = table1$model_id)

table1 <- table1 |>
  dplyr::left_join(stats_df, by = "model_id") |>
  dplyr::mutate(
    AICc = round(AICc, 2),
    `ΔAICc` = round(`ΔAICc`, 2),
    w = round(w, 3),
    `Adj. R²` = round(`Adj. R²`, 3)
  )


group_order <- c("Baseline","Rain","Temperature","Wind","Hail","Joint effects","Interactions")

model_group <- function(m){
  dplyr::case_when(
    m == "null" ~ "Baseline",
    m %in% c("total_rain","rain_days","max_rain","lag_total_rain") ~ "Rain",
    m %in% c("mean_temp","max_temp","min_temp") ~ "Temperature",
    m %in% c("mean_wind","max_wind") ~ "Wind",
    m %in% c("hail_days") ~ "Hail",
    m %in% c("minT_totalR","minT_maxR","minT_maxW","hail_maxW","maxR_maxW","maxT_rainDays","hail_rainDays") ~ "Joint effects",
    m %in% c("minT_x_rainDays","minT_x_meanWind","lagR_x_maxT") ~ "Interactions",
    TRUE ~ "Joint effects"
  )
}

pretty_model <- function(x){
  dplyr::recode(
    x,
    "null"            = "Intercept only",
    "total_rain"      = "Total rainfall",
    "rain_days"       = "Rainy days",
    "max_rain"        = "Maximum daily rainfall",
    "lag_total_rain"  = "Previous year's total rainfall",
    "mean_temp"       = "Mean temperature",
    "max_temp"        = "Maximum temperature",
    "min_temp"        = "Minimum temperature",
    "mean_wind"       = "Mean wind speed",
    "max_wind"        = "Maximum wind speed",
    "hail_days"       = "Hail days",
    "minT_totalR"     = "Min temperature + total rainfall",
    "minT_maxR"       = "Min temperature + max daily rainfall",
    "minT_maxW"       = "Min temperature + max wind speed",
    "hail_maxW"       = "Hail days + max wind speed",
    "maxR_maxW"       = "Max daily rainfall + max wind speed",
    "maxT_rainDays"   = "Max temperature + rainy days",
    "hail_rainDays"   = "Hail days + rainy days",
    "minT_x_rainDays" = "Min temperature × rainy days",
    "minT_x_meanWind" = "Min temperature × mean wind speed",
    "lagR_x_maxT"     = "Prev. rainfall × max temperature",
    .default = x
  )
}

table1_clean <- table1 |>
  dplyr::mutate(
    Group = model_group(model_id),
    Model = pretty_model(model_id),
    Group = factor(Group, levels = group_order)
  ) |>
  dplyr::arrange(Group, `ΔAICc`) |>
  dplyr::select(Group, Model, K, AICc, `ΔAICc`, w, `Adj. R²`, `slope (SE)`)


table2_raw <- table1_clean
names(table2_raw) <- trimws(names(table2_raw))


u_groups <- levels(droplevels(table2_raw$Group))

out <- bind_rows(lapply(u_groups, function(g){

  header_row <- table2_raw %>%
    filter(Group == g) %>%
    select(-Group) %>%
    slice(1) %>%
    mutate(across(everything(), ~ NA)) %>%
    mutate(Model = as.character(g))

  data_rows <- table2_raw %>%
    filter(Group == g) %>%
    select(-Group)

  header_row$is_group <- TRUE
  data_rows$is_group  <- FALSE

  bind_rows(header_row, data_rows)
}))

group_idx <- which(out$is_group)
out_ft <- out %>% select(-is_group)

ft <- flextable(out_ft) %>%
  font(fontname = "Times New Roman", part = "all") %>%
  fontsize(size = 12, part = "all") %>%
  bold(part = "header") %>%
  bg(part = "header", bg = "#f2f2f2") %>%
  bold(i = group_idx, part = "body") %>%
  bg(i = group_idx, bg = "#e6e6e6", part = "body") %>%
  align(j = 1, align = "left", part = "all") %>%
  align(j = 2:ncol(out_ft), align = "center", part = "all") %>%
  width(j = 1, width = 4.2) %>%
  width(j = 2:ncol(out_ft), width = 1.0) %>%
  autofit()

doc <- read_docx() %>%
  body_add_flextable(ft)

print(doc, target = "Table_1_BreedingEffort.docx")


```












```{r}
library(dplyr)
library(ggplot2)
library(forcats)
library(tidytext)   

daic_keep <- 4

effort_bar_df2 <- bind_rows(
  prep_aictab_bar(aic_effort_with_year, "With year"),
  prep_aictab_bar(aic_effort_no_year,   "Without year")
) |>
  group_by(panel) |>
  filter(dAICc <= daic_keep) |>
  mutate(
    
    label_w = tidytext::reorder_within(label, dAICc, panel)

  ) |>
  ungroup()

ggplot(effort_bar_df2, aes(x = label_w, y = dAICc, fill = is_best)) +
  geom_col(width = 0.7) +
  coord_flip() +
  geom_hline(yintercept = 2, linetype = "dashed") +
  facet_wrap(~panel, scales = "free_y") +
  tidytext::scale_x_reordered() +
  scale_fill_manual(values = c(`TRUE` = "steelblue", `FALSE` = "grey75"), guide = "none") +
  scale_y_continuous(limits = c(0, daic_keep), breaks = 0:daic_keep) +
  labs(
    x = NULL,
    y = expression(Delta*AIC[c]),
    title = 
"Objective 1: Model support for breeding effort",
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())

```
 


--------------------------------------------------------------------------------


### Objective 2: Breeding success

```{r}
objective2_table <- tribble(
  ~`Hypothesis / justification`, ~Model,

  # ---- Temperature ----
  "**Temp**", "",
  "Extreme heat events cause chick heat stress and dehydration, reducing fledging success",
  "success ~ max_temp + (1 | year)",

  "Cold extremes increase thermoregulatory demand in chicks, increasing mortality risk",
  "success ~ min_temp + (1 | year)",

  # ---- Rain ----
  "**Rain**", "",
  "Prolonged rainfall reduces adult foraging efficiency, limiting food delivery to chicks and reducing breeding success",
  "success ~ rain_days + (1 | year)",

  "Intense rainfall events cause acute nest disturbance and chick exposure, reducing breeding success",
  "success ~ max_rain + (1 | year)",

  "Overall wet years reduce provisioning efficiency across the breeding season, lowering breeding success",
  "success ~ total_rain + (1 | year)",

  # ---- Wind ----
  "**Wind**", "",
  "Extreme winds increase nest exposure and disrupt provisioning, reducing chick survival",
  "success ~ max_wind + (1 | year)",

  # ---- Hail ----
  "**Hail**", "",
  "Severe hail events increase nest destruction and chick mortality, reducing breeding success",
  "success ~ hail_days + (1 | year)",

  # ---- Joint Effects ----
  "**Joint effects**", "",
  "Severe storm exposure increases nest destruction and chick mortality, reducing breeding success",
  "success ~ hail_days + max_wind + (1 | year)",

  "Prolonged wet conditions combined with storm events increase chick exposure and limit provisioning, reducing breeding success",
  "success ~ rain_days + hail_days + (1 | year)",

  "Heat stress combined with prolonged wet conditions reduces chick thermoregulation and food delivery, lowering breeding success",
  "success ~ max_temp + rain_days + (1 | year)",

  # ---- Interactive Effects ----
  "**Interactive effects**", "",
  "The negative effect of heat stress on breeding success is amplified during persistently wet conditions that limit adult foraging",
  "success ~ max_temp * rain_days + (1 | year)",

  "Cold stress on chicks is amplified during extreme wind events due to increased exposure and heat loss, reducing breeding success",
  "success ~ min_temp * max_wind + (1 | year)"
)

kable(
  objective2_table,
  align = c("l", "l"),
  caption = "Objective 2 candidate model set for breeding success. All models are fitted as binomial GLMMs: cbind(success_nests, failed_nests) with a random intercept for year (1 | year)"
)
```

success ~ 1 + (1 | year)

```{r}
library(lme4)

success_df <- success_df |> mutate(year = factor(year))

m0 <- glmer(
  cbind(success_nests, failed_nests) ~ 1 + (1 | year),
  family = binomial,
  data = success_df
)
summary(m0)

```

```{r}
library(lme4)

success_df <- success_df |> dplyr::mutate(year = factor(year))

# Baseline (null) model

m0_success <- glmer(
  cbind(success_nests, failed_nests) ~ 1 + (1 | year),
  family = binomial,
  data = success_df
)

# Single predictor models

m_succ_maxT <- glmer(
  cbind(success_nests, failed_nests) ~ z_max_temp + (1 | year),
  family = binomial, data = success_df
)

m_succ_minT <- glmer(
  cbind(success_nests, failed_nests) ~ z_min_temp + (1 | year),
  family = binomial, data = success_df
)

m_succ_rainD <- glmer(
  cbind(success_nests, failed_nests) ~ z_rain_days + (1 | year),
  family = binomial, data = success_df
)

m_succ_maxR <- glmer(
  cbind(success_nests, failed_nests) ~ z_max_rain + (1 | year),
  family = binomial, data = success_df
)

m_succ_totR <- glmer(
  cbind(success_nests, failed_nests) ~ z_total_rain + (1 | year),
  family = binomial, data = success_df
)

m_succ_maxW <- glmer(
  cbind(success_nests, failed_nests) ~ z_max_wind + (1 | year),
  family = binomial, data = success_df
)

m_succ_hail <- glmer( 
  cbind(success_nests, failed_nests) ~ z_hail_days + (1 | year),
  family = binomial, data = success_df
)

# Joint effects

m_succ_hailW <- glmer(
  cbind(success_nests, failed_nests) ~ z_hail_days + z_max_wind + (1 | year),
  family = binomial, data = success_df
)

m_succ_rainH <- glmer(
  cbind(success_nests, failed_nests) ~ z_rain_days + z_hail_days + (1 | year),
  family = binomial, data = success_df
)

m_succ_heatR <- glmer(
  cbind(success_nests, failed_nests) ~ z_max_temp + z_rain_days + (1 | year),
  family = binomial, data = success_df
)

# Interactions

m_succ_int_heat_rain <- glmer(
  cbind(success_nests, failed_nests) ~ z_max_temp * z_rain_days + (1 | year),
  family = binomial, data = success_df
)

m_succ_int_cold_wind <- glmer(
  cbind(success_nests, failed_nests) ~ z_min_temp * z_max_wind + (1 | year),
  family = binomial, data = success_df
)

```

```{r}

# Candidate set + AIC

library(AICcmodavg)

cand_success <- list(
  null_re      = m0_success,

  max_temp     = m_succ_maxT,
  min_temp     = m_succ_minT,
  rain_days    = m_succ_rainD,
  max_rain     = m_succ_maxR,
  total_rain   = m_succ_totR,
  max_wind     = m_succ_maxW,
  hail_days    = m_succ_hail,

  hail_maxW    = m_succ_hailW,
  rain_hail    = m_succ_rainH,
  maxT_rainD   = m_succ_heatR,

  int_heatRain = m_succ_int_heat_rain,
  int_coldWind = m_succ_int_cold_wind
)

aic_success <- aictab(
  cand.set  = cand_success,
  modnames  = names(cand_success)
)

aic_success

```


```{r}
vc_year <- function(mod) {
  vc <- as.data.frame(VarCorr(mod))
  vc$vcov[vc$grp == "year"][1]
}

v0     <- vc_year(m0_success)
v_minT <- vc_year(m_succ_minT)

prop_between_year_explained <- (v0 - v_minT) / v0
prop_between_year_explained

```

### Figures and tables 

```{r}
library(dplyr)
library(tibble)
library(lme4)
library(AICcmodavg)
library(officer)
library(flextable)


aic_df <- as.data.frame(aic_success)


if ("Modnames" %in% names(aic_df)) {
  aic_df <- aic_df %>% mutate(model_id = Modnames)
} else {
  aic_df <- tibble::rownames_to_column(aic_df, "model_id")
}


table_success <- aic_df %>%
  rename(
    `ΔAICc` = Delta_AICc,
    w       = AICcWt
  ) %>%
  select(model_id, K, AICc, `ΔAICc`, w) %>%
  arrange(`ΔAICc`)


vc_year <- function(mod) {
  vc <- as.data.frame(VarCorr(mod))
  vc$vcov[vc$grp == "year"][1]
}

v0 <- vc_year(m0_success)


get_stats_success <- function(mod){
 
  fe <- lme4::fixef(mod)
  if (length(fe) == 2) {
    cf <- summary(mod)$coefficients
    slope_se <- paste0(round(cf[2,1], 3), " (", round(cf[2,2], 3), ")")
  } else {
    slope_se <- ""
  }

  v_mod <- vc_year(mod)
  var_expl <- if (is.finite(v_mod) && is.finite(v0) && v0 > 0) (v0 - v_mod) / v0 else NA_real_

  tibble::tibble(`Variance explained` = var_expl, `slope (SE)` = slope_se)
}

stats_df <- lapply(table_success$model_id, function(mn) get_stats_success(cand_success[[mn]])) %>%
  bind_rows() %>%
  mutate(model_id = table_success$model_id)

table_success <- table_success %>%
  left_join(stats_df, by = "model_id") %>%
  mutate(
    AICc = round(AICc, 2),
    `ΔAICc` = round(`ΔAICc`, 2),
    w = round(w, 3),
    `Variance explained` = round(`Variance explained`, 3)
  )


group_order <- c("Baseline", "Temperature", "Rain", "Wind", "Hail", "Joint effects", "Interactions")

model_group_success <- function(m){
  dplyr::case_when(
    m %in% c("null_re") ~ "Baseline",
    m %in% c("max_temp", "min_temp") ~ "Temperature",
    m %in% c("rain_days", "max_rain", "total_rain") ~ "Rain",
    m %in% c("max_wind") ~ "Wind",
    m %in% c("hail_days") ~ "Hail",
    m %in% c("hail_maxW", "rain_hail", "maxT_rainD") ~ "Joint effects",
    m %in% c("int_heatRain", "int_coldWind") ~ "Interactions",
    TRUE ~ "Joint effects"
  )
}

pretty_model_success <- function(x){
  dplyr::recode(
    x,
    "null_re"      = "Intercept only",
    "max_temp"     = "Maximum temperature",
    "min_temp"     = "Minimum temperature",
    "rain_days"    = "Rainy days",
    "max_rain"     = "Maximum daily rainfall",
    "total_rain"   = "Total rainfall",
    "max_wind"     = "Maximum wind speed",
    "hail_days"    = "Hail days",
    "hail_maxW"    = "Hail days + max wind speed",
    "rain_hail"    = "Rainy days + hail days",
    "maxT_rainD"   = "Max temperature + rainy days",
    "int_heatRain" = "Max temperature × rainy days",
    "int_coldWind" = "Min temperature × max wind speed",
    .default = x
  )
}

table_success_clean <- table_success %>%
  mutate(
    Group = model_group_success(model_id),
    Model = pretty_model_success(model_id),
    Group = factor(Group, levels = group_order)
  ) %>%
  arrange(Group, `ΔAICc`) %>%
  select(Group, Model, K, AICc, `ΔAICc`, w, `Variance explained`, `slope (SE)`)


df <- table_success_clean %>%
  rename(`Deviance explained` = `Variance explained`) %>%
  select(Group, Model, K, AICc, `ΔAICc`, w, `Deviance explained`, `slope (SE)`) %>%
  mutate(Group = factor(Group, levels = c("Baseline","Temperature","Rain","Wind","Hail","Joint effects","Interactions"))) %>%
  arrange(Group, `ΔAICc`)

groups <- levels(droplevels(df$Group))
groups <- groups[groups %in% unique(as.character(df$Group))]

make_group_block <- function(g) {
  header <- df[0, ]
  header[1, ] <- NA
  header$Group <- g
  header$Model <- g
  header$is_group <- TRUE

  rows <- df %>% filter(as.character(Group) == g)
  rows$is_group <- FALSE

  bind_rows(header, rows)
}

df2 <- bind_rows(lapply(groups, make_group_block))
group_rows <- which(df2$is_group)

df_print <- df2 %>% select(-Group, -is_group)

ft <- flextable(df_print) %>%
  font(fontname = "Times New Roman", part = "all") %>%
  fontsize(size = 12, part = "all") %>%
  bold(part = "header") %>%
  bg(part = "header", bg = "#f2f2f2") %>%
  align(j = 1, align = "left", part = "all") %>%
  align(j = 2:ncol(df_print), align = "center", part = "all") %>%
  bg(i = group_rows, bg = "#e6e6e6", part = "body") %>%
  bold(i = group_rows, part = "body") %>%
  autofit()

doc <- read_docx() %>%
  body_add_flextable(ft)

print(doc, target = "Table_3_Breeding_Success.docx")

```


```{r}
library(dplyr)
library(tibble)
library(lme4)
library(AICcmodavg)
library(flextable)
library(officer)

# ---------------- helpers ----------------
vc_year <- function(mod) {
  vc <- as.data.frame(VarCorr(mod))
  out <- vc$vcov[vc$grp == "year"][1]
  if (length(out) == 0) NA_real_ else out
}

slope_se_single <- function(mod, digits = 3){
  fe <- lme4::fixef(mod)
  # only print slope (SE) for 1-predictor + intercept models
  if (length(fe) == 2) {
    cf <- summary(mod)$coefficients
    paste0(
      round(cf[2, 1], digits),
      " (", round(cf[2, 2], digits), ")"
    )
  } else {
    ""
  }
}

annual_var_expl_factory <- function(null_mod){
  v0 <- vc_year(null_mod)
  function(mod){
    v_mod <- vc_year(mod)
    if (is.finite(v_mod) && is.finite(v0) && v0 > 0) max(0, (v0 - v_mod)/v0) else NA_real_
  }
}

# ---------------- 1) AIC table to data frame ----------------
aic_df <- as.data.frame(aic_success)

if ("Modnames" %in% names(aic_df)) {
  aic_df <- aic_df %>% mutate(model_id = Modnames)
} else {
  aic_df <- tibble::rownames_to_column(aic_df, "model_id")
}

table_success <- aic_df %>%
  rename(`ΔAICc` = Delta_AICc, w = AICcWt) %>%
  select(model_id, K, AICc, `ΔAICc`, w) %>%
  arrange(`ΔAICc`)

# ---------------- 2) Add between-year variance explained + slope(SE) ----------------
var_expl_fun <- annual_var_expl_factory(m0_success)

stats_df <- table_success %>%
  mutate(
    `Between-year variance explained` =
      sapply(model_id, function(mn) var_expl_fun(cand_success[[mn]])),
    `slope (SE)` =
      sapply(model_id, function(mn) slope_se_single(cand_success[[mn]]))
  )

table_success2 <- table_success %>%
  left_join(stats_df %>% select(model_id, `Between-year variance explained`, `slope (SE)`),
            by = "model_id") %>%
  mutate(
    AICc = round(AICc, 2),
    `ΔAICc` = round(`ΔAICc`, 2),
    w = round(w, 3),
    `Between-year variance explained` = round(`Between-year variance explained`, 3)
  )

# ---------------- 3) Grouping + pretty names ----------------
group_order <- c("Baseline", "Temperature", "Rain", "Wind", "Hail", "Joint effects", "Interactions")

model_group_success <- function(m){
  dplyr::case_when(
    m %in% c("null_re") ~ "Baseline",
    m %in% c("max_temp", "min_temp") ~ "Temperature",
    m %in% c("rain_days", "max_rain", "total_rain") ~ "Rain",
    m %in% c("max_wind") ~ "Wind",
    m %in% c("hail_days") ~ "Hail",
    m %in% c("hail_maxW", "rain_hail", "maxT_rainD") ~ "Joint effects",
    m %in% c("int_heatRain", "int_coldWind") ~ "Interactions",
    TRUE ~ "Joint effects"
  )
}

pretty_model_success <- function(x){
  dplyr::recode(
    x,
    "null_re"      = "Intercept only",
    "max_temp"     = "Maximum temperature",
    "min_temp"     = "Minimum temperature",
    "rain_days"    = "Rainy days",
    "max_rain"     = "Maximum daily rainfall",
    "total_rain"   = "Total rainfall",
    "max_wind"     = "Maximum wind speed",
    "hail_days"    = "Hail days",
    "hail_maxW"    = "Hail days + max wind speed",
    "rain_hail"    = "Rainy days + hail days",
    "maxT_rainD"   = "Max temperature + rainy days",
    "int_heatRain" = "Max temperature × rainy days",
    "int_coldWind" = "Min temperature × max wind speed",
    .default = x
  )
}

df <- table_success2 %>%
  mutate(
    Group = factor(model_group_success(model_id), levels = group_order),
    Model = pretty_model_success(model_id)
  ) %>%
  arrange(Group, `ΔAICc`) %>%
  select(Group, Model, K, AICc, `ΔAICc`, w, `Between-year variance explained`, `slope (SE)`)

# ---------------- 4) Insert grey group header rows ----------------
groups <- levels(droplevels(df$Group))
groups <- groups[groups %in% unique(as.character(df$Group))]

make_group_block <- function(g) {
  header <- df[0, ]
  header[1, ] <- NA
  header$Group <- g
  header$Model <- g
  header$is_group <- TRUE

  rows <- df %>% filter(as.character(Group) == g)
  rows$is_group <- FALSE

  bind_rows(header, rows)
}

df2 <- bind_rows(lapply(groups, make_group_block))
group_rows <- which(df2$is_group)

df_print <- df2 %>% select(-Group, -is_group)

# ---------------- 5) Flextable + export ----------------
ft <- flextable(df_print) %>%
  font(fontname = "Times New Roman", part = "all") %>%
  fontsize(size = 12, part = "all") %>%
  bold(part = "header") %>%
  bg(part = "header", bg = "#f2f2f2") %>%
  align(j = 1, align = "left", part = "all") %>%
  align(j = 2:ncol(df_print), align = "center", part = "all") %>%
  bg(i = group_rows, bg = "#e6e6e6", part = "body") %>%
  bold(i = group_rows, part = "body") %>%
  autofit()

doc <- read_docx() %>% body_add_flextable(ft)
print(doc, target = "Table_2_Breeding_Success_REBUILT.docx")
```





```{r}
obs_df <- success_df |>
  mutate(
    success_rate = success_nests / (success_nests + failed_nests),
    se = sqrt(success_rate * (1 - success_rate) /
                (success_nests + failed_nests))
  )

```

```{r}
minT_model <- m_succ_minT

pred_df <- success_df |>
  mutate(
    pred = predict(
      minT_model,
      newdata = success_df,
      type = "response",
      re.form = NA
    )
  )

```



```{r}
succ_clean <- as.data.frame(aic_success)

if (!("model_id" %in% names(succ_clean))) {
  if ("Modnames" %in% names(succ_clean)) succ_clean$model_id <- succ_clean$Modnames
  else succ_clean$model_id <- rownames(succ_clean)
}

if (!("dAICc" %in% names(succ_clean))) {
  if ("Delta_AICc" %in% names(succ_clean)) succ_clean$dAICc <- succ_clean$Delta_AICc
  else if ("Delta.AICc" %in% names(succ_clean)) succ_clean$dAICc <- succ_clean$Delta.AICc
  else stop("Can't find dAICc / Delta_AICc in aic_success.")
}

if (!("label" %in% names(succ_clean))) {
  succ_clean$label <- succ_clean$model_id
}

succ_clean <- succ_clean |>
  dplyr::mutate(
    dAICc_plot = dplyr::if_else(model_id == "min_temp", 0.05, dAICc)
  )

```

```{r}
succ_clean <- succ_clean |> 
  mutate(dAICc_plot = if_else(model_id == "min_temp", 0.05, dAICc))

ggplot() +
  geom_col(
    data = succ_clean,
    aes(x = label, y = dAICc_plot),
    width = 0.7,
    fill = "grey75"
  ) +
  geom_col(
    data = succ_clean |>  filter(model_id == "min_temp"),
    aes(x = label, y = dAICc_plot),
    width = 0.7,
    fill = "steelblue"
  ) +
  coord_flip() +
  geom_hline(yintercept = 2, linetype = "dashed") +
  labs(
    title = "Model support for breeding success",
    subtitle = "ΔAICc values; best model visually offset",
    x = NULL,
    y = expression(Delta*AIC[c])
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())


```


```{r}
library(ggeffects)
library(dplyr)
library(ggplot2)

pred_minT <- ggpredict(
  m_succ_minT,
  terms = "z_min_temp [all]",
  type = "fixed"
) |>
  as.data.frame() |>
  rename(
    x = x,
    predicted = predicted,
    conf.low = conf.low,
    conf.high = conf.high
  )

# observed annual success
obs_pts <- success_df |>
  mutate(success_rate = success_nests / (success_nests + failed_nests))

ggplot() +
  geom_point(
    data = obs_pts,
    aes(x = z_min_temp, y = success_rate),
    colour = "#B1BD8C",
    alpha = 0.7,
    size = 2.6
  ) +
  geom_ribbon(
    data = pred_minT,
    aes(x = x, ymin = conf.low, ymax = conf.high),
    fill = "#D5D6D2",
    alpha = 0.4
  ) +
  geom_line(
    data = pred_minT,
    aes(x = x, y = predicted),
    colour = "#D5D6D2",
    linewidth = 1.2
  ) +
  labs(
    x = "Minimum temperature (standardised)",
    y = "Breeding success"
  ) +
  theme_bw(base_family = "Times New Roman") +
  theme(
    panel.grid = element_blank(),
    axis.title = element_text(face = "bold", size = 12),
    axis.text  = element_text(face = "bold", size = 12)
  )



```

### Adding population size to the best supported models:

```{r}
success_df <- success_df |>
  mutate(z_active_nests = scale(active_nests))

```

```{r}
m_succ_pop <- glmer(
  cbind(success_nests, failed_nests) ~ z_active_nests + (1 | year),
  family = binomial,
  data = success_df
)

```

```{r}
m_succ_minT_pop <- glmer(
  cbind(success_nests, failed_nests) ~ z_min_temp + z_active_nests + (1 | year),
  family = binomial,
  data = success_df
)

```


```{r}
summary(m_succ_pop)

```
```{r}
summary(m_succ_minT)
summary(m_succ_minT_pop)

```

```{r}
aictab(list(
  min_temp      = m_succ_minT,
  min_temp_pop  = m_succ_minT_pop,
  pop_only      = m_succ_pop
))

```

```{r}
summary(m_succ_minT_pop)

```
```{r}
vc_year <- function(mod) {
  vc <- as.data.frame(VarCorr(mod))
  vc$vcov[vc$grp == "year"][1]
}

v0 <- vc_year(m0_success)
v1 <- vc_year(m_succ_minT_pop)

prop_between_year_explained <- (v0 - v1) / v0
prop_between_year_explained

```
```{r}
v_minT <- vc_year(m_succ_minT)

prop_minT <- (v0 - v_minT) / v0
prop_minT

```

```{r}
v_pop <- vc_year(m_succ_pop)

prop_pop <- (v0 - v_pop) / v0
prop_pop

```

```{r}
library(dplyr)
library(tibble)
library(flextable)
library(officer)

sens_tbl <- tibble(
  Model = c(
    "Minimum temperature",
    "Population size",
    "Minimum temperature + population size"
  ),
  `ΔAICc` = c(6.91, 5.44, 0.00),
  `AIC weight` = c(0.03, 0.06, 0.91),
  `Between-year variance explained` = c(0.21, 0.24, 0.50)
)


ft <- flextable(sens_tbl)

ft <- ft |>
  font(fontname = "Times New Roman", part = "all") |>
  fontsize(size = 12, part = "all") |>
  bold(part = "header") |>
  bg(part = "header", bg = "#f2f2f2") |>
  align(j = 1, align = "left", part = "all") |>
  align(j = 2:ncol(sens_tbl), align = "center", part = "all") |>
  autofit()


doc <- read_docx() |>
  body_add_flextable(ft)

print(doc, target = "Sensitivity_Table.docx")



```









```{r}
library(dplyr)
library(tidyr)
library(tibble)
library(lme4)
library(AICcmodavg)
library(officer)
library(flextable)

# ---------------- helpers ----------------
dev_m2ll <- function(mod) -2 * as.numeric(logLik(mod))
get_K <- function(mod) attr(logLik(mod), "df")

vc_year <- function(mod) {
  vc <- as.data.frame(VarCorr(mod))
  out <- vc$vcov[vc$grp == "year"][1]
  if (length(out) == 0) NA_real_ else out
}

annual_var_expl_factory <- function(null_mod){
  v0 <- vc_year(null_mod)
  function(mod){
    v_mod <- vc_year(mod)
    if (is.finite(v_mod) && is.finite(v0) && v0 > 0) max(0, (v0 - v_mod)/v0) else NA_real_
  }
}

slope_se_single <- function(mod, digits = 3){
  fe <- fixef(mod)
  if (length(fe) == 2) {
    cf <- summary(mod)$coefficients
    paste0(round(cf[2,1], digits), " (", round(cf[2,2], digits), ")")
  } else ""
}

build_block <- function(cand_list, null_name = "null_re") {
  stopifnot(null_name %in% names(cand_list))
  ann_expl <- annual_var_expl_factory(cand_list[[null_name]])

  bind_rows(lapply(names(cand_list), function(nm){
    mod <- cand_list[[nm]]
    tibble(
      model_id = nm,
      K = get_K(mod),
      Deviance = dev_m2ll(mod),
      AICc = AICc(mod),
      `Annual variance explained` = ann_expl(mod),
      `slope (SE)` = slope_se_single(mod)
    )
  })) %>%
    arrange(AICc) %>%
    mutate(
      `ΔAICc` = AICc - min(AICc, na.rm = TRUE),
      w = exp(-0.5 * `ΔAICc`) / sum(exp(-0.5 * `ΔAICc`)),
      Deviance = round(Deviance, 2),
      AICc = round(AICc, 2),
      `ΔAICc` = round(`ΔAICc`, 2),
      w = round(w, 3),
      `Annual variance explained` = round(`Annual variance explained`, 3)
    )
}

# ---------------------------
# A) MAIN block (your existing candidate set)
# ---------------------------
stopifnot(exists("cand_timing_30"))
main_tbl <- build_block(cand_timing_30, null_name = "null_re")

# your model_key should exist; drop pop rows from model_key here if you want
main_tbl <- main_tbl %>%
  left_join(model_key, by = "model_id") %>%
  filter(is.na(Group) | Group != "Population size (post hoc)") %>%
  mutate(
    Group = coalesce(Group, "Other"),
    Model = coalesce(Model, model_id),
    block = "main"
  )

# ---------------------------
# B) POST HOC block (fit & rank only within subset)
# ---------------------------
timing_weather_30_cc_pop <- timing_weather_30 %>%
  mutate(year = factor(year)) %>%
  dplyr::select(lay_DOY, year, mean_temp_30, rain_days_30, z_active_nests) %>%
  tidyr::drop_na()

null_pop <- lmer(lay_DOY ~ 1 + (1|year), data = timing_weather_30_cc_pop, REML = FALSE)

best_weather_pop <- lmer(lay_DOY ~ mean_temp_30 * rain_days_30 + (1|year),
                         data = timing_weather_30_cc_pop, REML = FALSE)

pop_only <- lmer(lay_DOY ~ z_active_nests + (1|year),
                 data = timing_weather_30_cc_pop, REML = FALSE)

best_pop <- lmer(lay_DOY ~ mean_temp_30 * rain_days_30 + z_active_nests + (1|year),
                 data = timing_weather_30_cc_pop, REML = FALSE)

cand_pop <- list(
  null_re = null_pop,
  best_weather = best_weather_pop,
  pop_only = pop_only,
  best_pop = best_pop
)

post_tbl <- build_block(cand_pop, null_name = "null_re") %>%
  mutate(
    Group = "Population size (post hoc; subset)",
    Model = recode(
      model_id,
      "null_re" = "Intercept only (post hoc subset)",
      "best_weather" = "Best weather model (post hoc subset)",
      "pop_only" = "Population size (z active nests)",
      "best_pop" = "Best weather model + population size",
      .default = model_id
    ),
    block = "posthoc"
  )

# ---------------------------
# C) Combine into ONE printed table
# (AICc shown for each model, but ΔAICc/w are WITHIN-BLOCK)
# ---------------------------
group_order <- c(
  "Baseline","Temperature","Rain","Wind","Lagged effects",
  "Joint effects","Interactive effects",
  "Population size (post hoc; subset)",
  "Other"
)

df <- bind_rows(main_tbl, post_tbl) %>%
  mutate(Group = factor(Group, levels = group_order)) %>%
  arrange(Group, `ΔAICc`) %>%
  transmute(
    Group, Model, K, Deviance, AICc, `ΔAICc`, w,
    `Annual variance explained`, `slope (SE)`
  )

# Group header rows
groups <- df %>%
  filter(!is.na(Group)) %>%
  pull(Group) %>%
  unique() %>%
  as.character()

make_group_block <- function(g) {
  header <- df[0, ]
  header[1, ] <- NA
  header$Group <- g
  header$Model <- g
  header$is_group <- TRUE

  rows <- df %>% filter(as.character(Group) == g)
  rows$is_group <- FALSE
  bind_rows(header, rows)
}

df2 <- bind_rows(lapply(groups, make_group_block))
group_rows <- which(df2$is_group)
df_print <- df2 %>% select(-Group, -is_group)

# ---------------------------
# Flextable styling
# ---------------------------
ft <- flextable(df_print) %>%
  font(fontname = "Times New Roman", part = "all") %>%
  fontsize(size = 12, part = "all") %>%
  bold(part = "header") %>%
  bg(part = "header", bg = "#f2f2f2") %>%
  align(j = 1, align = "left", part = "all") %>%
  align(j = 2:ncol(df_print), align = "center", part = "all") %>%
  bg(i = group_rows, bg = "#e6e6e6", part = "body") %>%
  bold(i = group_rows, part = "body") %>%
  autofit()

for (r in group_rows) {
  ft <- merge_at(ft, i = r, j = 1:ncol(df_print), part = "body")
  ft <- align(ft, i = r, j = 1, align = "left", part = "body")
}

# ---------------------------
# Export to Word
# ---------------------------
doc <- read_docx() %>%
  body_add_par(
    paste0(
      "Table 3. Model selection results for breeding timing (laying date, day of year). ",
      "Main candidate-set models were fitted to a consistent complete-case dataset. ",
      "Population-size models were fitted post hoc on the subset of years with population-size data; ",
      "ΔAICc and w for those models are computed within that post hoc subset and are not directly comparable to the main candidate set."
    ),
    style = "Normal"
  ) %>%
  body_add_flextable(ft)

print(doc, target = "Table_Breeding_Timing_Combined_with_PosthocBlock.docx")
```


```{r}
mods <- list(
  null = m0_success,
  maxT = m_succ_maxT,
  minT = m_succ_minT,
  rainD = m_succ_rainD,
  maxR = m_succ_maxR,
  totR = m_succ_totR,
  maxW = m_succ_maxW,
  hail = m_succ_hail,
  hailW = m_succ_hailW,
  rainH = m_succ_rainH,
  heatR = m_succ_heatR,
  int_heat_rain = m_succ_int_heat_rain,
  int_cold_wind = m_succ_int_cold_wind
)

sapply(mods, function(m) attr(logLik(m), "df"))
```

--------------------------------------------------------------------------------

### Objective 3

```{r}
hist(timing_weather_60$lay_DOY)
qqnorm(timing_weather_60$lay_DOY)
qqline(timing_weather_60$lay_DOY)

```


```{r}
objective3_table <- tribble(
  ~`Hypothesis / justification`, ~Model,

  # ---- Temperature (pre-laying cues) ----
  "**Temp (pre-laying)**", "",
  "Short-term warm conditions prior to laying may act as a cue for the initiation of breeding.",
  "lay_DOY ~ mean_temp_30",

  "Cold pre-laying conditions delay breeding due to increased energetic costs",
  "lay_DOY ~ min_temp_30",


  # ---- Rain (pre-laying cues) ----
  "**Rain (pre-laying)**", "",
  "Prolonged wet conditions prior to laying delay breeding by limiting foraging efficiency",
  "lay_DOY ~ rain_days_30",

  "Higher rainfall prior to laying signals improved food availability and advances breeding timing",
  "lay_DOY ~ total_rain_30",

  # ---- Wind (pre-laying flight conditions) ----
  "**Wind (pre-laying)**", "",
  "Persistent windy conditions prior to laying increase flight costs and delay breeding timing",
  "lay_DOY ~ mean_wind_30",

  # ---- Lagged effects (carry-over cues) ----
  "**Lagged effects (previous year)**", "",
  "Higher rainfall in the previous year improves food availability and adult condition entering the breeding season, allowing vultures to initiate breeding earlier",
  "lay_DOY ~ lag_total_rain",

  "Prolonged wet conditions in the previous year may influence adult condition and carry over to affect laying timing",
  "lay_DOY ~ lag_rain_days",

  "Thermal conditions in the previous year influence physiological state entering the breeding season",
  "lay_DOY ~ lag_mean_temp",

  # ---- Joint effects ----
  "**Joint effects**", "",
  "Temperature and rainfall cues prior to laying jointly influence breeding timing",
  "lay_DOY ~ mean_temp_30 + rain_days_30",

  "Carry-over effects from the previous year interact with current pre-laying rainfall cues",
  "lay_DOY ~ lag_total_rain + rain_days_30",

  "Previous-year rainfall and current temperature jointly influence breeding timing",
  "lay_DOY ~ lag_total_rain + mean_temp_30",

  # ---- Interactive effects ----
  "**Interactive effects**", "",
  "The effect of temperature cues on breeding timing depends on pre-laying rainfall conditions",
  "lay_DOY ~ mean_temp_30 * rain_days_30",

  "Carry-over effects from the previous year modify responses to current pre-laying temperature cues",
  "lay_DOY ~ lag_total_rain * mean_temp_30"
)

kable(
  objective3_table,
  align = c("l", "l"),
  caption = "Objective 3 candidate model set for breeding timing (laying date, day of year)."
)
```

```{r}
names(timing_weather_30)
```

```{r}
vars_30 <- c(
  "lay_DOY", "year",
  "mean_temp_30", "max_temp_30", "min_temp_30",
  "total_rain_30", "rain_days_30",
  "mean_wind_30", "max_wind_30", "hail_days_30",
  "lag_mean_temp", "lag_total_rain", "lag_rain_days"
)

timing_weather_30_cc <- timing_weather_30 %>%
  dplyr::select(all_of(vars_30)) %>%
  tidyr::drop_na()

nrow(timing_weather_30_cc)
```


```{r}
library(lme4)

cand_timing_30 <- list(

  # ---- baseline ----
  null_re = lmer(lay_DOY ~ 1 + (1 | year),
                 data = timing_weather_30_cc, REML = FALSE),

  # ---- temperature cues ----
  meanT_30 = lmer(lay_DOY ~ mean_temp_30 + (1 | year),
                  data = timing_weather_30_cc, REML = FALSE),

  maxT_30 = lmer(lay_DOY ~ max_temp_30 + (1 | year),
                 data = timing_weather_30_cc, REML = FALSE),

  minT_30 = lmer(lay_DOY ~ min_temp_30 + (1 | year),
                 data = timing_weather_30_cc, REML = FALSE),

  # ---- rainfall cues ----
  rainDays_30 = lmer(lay_DOY ~ rain_days_30 + (1 | year),
                     data = timing_weather_30_cc, REML = FALSE),

  totalR_30 = lmer(lay_DOY ~ total_rain_30 + (1 | year),
                   data = timing_weather_30_cc, REML = FALSE),

  # ---- wind constraints ----
  meanW_30 = lmer(lay_DOY ~ mean_wind_30 + (1 | year),
                  data = timing_weather_30_cc, REML = FALSE),

  maxW_30 = lmer(lay_DOY ~ max_wind_30 + (1 | year),
                 data = timing_weather_30_cc, REML = FALSE),

  # ---- lagged carry-over ----
  lagMeanT = lmer(lay_DOY ~ lag_mean_temp + (1 | year),
                  data = timing_weather_30_cc, REML = FALSE),

  lagTotR = lmer(lay_DOY ~ lag_total_rain + (1 | year),
                 data = timing_weather_30_cc, REML = FALSE),

  lagRainD = lmer(lay_DOY ~ lag_rain_days + (1 | year),
                  data = timing_weather_30_cc, REML = FALSE),

  # ---- additive ----
  temp_rain = lmer(lay_DOY ~ mean_temp_30 + rain_days_30 + (1 | year),
                   data = timing_weather_30_cc, REML = FALSE),

  # ---- interactions ----
  temp_x_rain = lmer(lay_DOY ~ mean_temp_30 * rain_days_30 + (1 | year),
                     data = timing_weather_30_cc, REML = FALSE)
)
```
```{r}
sapply(cand_timing_30, nobs)
```


```{r}

aic_timing_30 <- aictab(
  cand.set = cand_timing_30,
  modnames = names(cand_timing_30)
)

aic_timing_30

```

```{r}

cand_timing_60 <- list(

  meanT_60   = lm(lay_DOY ~ mean_temp_60, data = timing_weather_60),
  maxT_60    = lm(lay_DOY ~ max_temp_60,  data = timing_weather_60),
  minT_60    = lm(lay_DOY ~ min_temp_60,  data = timing_weather_60),

  rainDays_60 = lm(lay_DOY ~ rain_days_60,  data = timing_weather_60),
  totalR_60   = lm(lay_DOY ~ total_rain_60, data = timing_weather_60),

  meanW_60 = lm(lay_DOY ~ mean_wind_60, data = timing_weather_60),
  maxW_60  = lm(lay_DOY ~ max_wind_60,  data = timing_weather_60),

  # lagged (previous year)
  lagTotR  = lm(lay_DOY ~ lag_total_rain, data = timing_weather_60),
  lagRainD = lm(lay_DOY ~ lag_rain_days,  data = timing_weather_60),
  lagMeanT = lm(lay_DOY ~ lag_mean_temp,  data = timing_weather_60),

  # additive
  temp_rain = lm(lay_DOY ~ mean_temp_60 + rain_days_60, data = timing_weather_60),
  temp_wind = lm(lay_DOY ~ mean_temp_60 + mean_wind_60, data = timing_weather_60),
  rain_wind = lm(lay_DOY ~ rain_days_60 + mean_wind_60, data = timing_weather_60),

  # interactions
  temp_x_rain = lm(lay_DOY ~ mean_temp_60 * rain_days_60, data = timing_weather_60),
  minT_x_wind = lm(lay_DOY ~ min_temp_60 * mean_wind_60, data = timing_weather_60),
  lagR_x_temp = lm(lay_DOY ~ lag_total_rain * mean_temp_60, data = timing_weather_60)
)

```

```{r}

aic_timing_60 <- aictab(
  cand.set = cand_timing_60,
  modnames = names(cand_timing_60)
)

```

```{r}
aic_timing_30
summary(cand_timing_30$temp_x_rain)$r.squared


aic_timing_60
summary(cand_timing_60$temp_x_rain)$r.squared

```

```{r}
m_year_trend <- lm(lay_DOY ~ year, data = timing_weather_30)
summary(m_year_trend)

``` 

```{r}
summary(m_year_trend)$r.squared

```

```{r}
m_year_trend60 <- lm(lay_DOY ~ year, data = timing_weather_60)
summary(m_year_trend60)

```


### Figures and Tables

```{r}
# ==============================
# Table 3 (Objective 3): Timing
# + add population size (post hoc) rows
# ==============================

library(dplyr)
library(tidyr)
library(tibble)
library(lme4)
library(AICcmodavg)
library(officer)
library(flextable)

# ---------------------------
# 0) Create post hoc datasets
# ---------------------------
# (a) Candidate-set complete cases (already defined earlier as timing_weather_30_cc)
# Make sure year is a factor for (1|year)
timing_weather_30_cc <- timing_weather_30_cc %>%
  mutate(year = factor(year))

# (b) Post hoc dataset that includes population size proxy (z_active_nests)
timing_weather_30_cc_pop <- timing_weather_30 %>%
  mutate(year = factor(year)) %>%
  dplyr::select(
    lay_DOY, year,
    mean_temp_30, rain_days_30,
    z_active_nests
  ) %>%
  tidyr::drop_na()

# ---------------------------
# 1) Fit post hoc pop models
# ---------------------------
# Population size only
m_pop_only <- lmer(
  lay_DOY ~ z_active_nests + (1 | year),
  data = timing_weather_30_cc_pop,
  REML = FALSE
)

# Best model + population size
m_best_pop <- lmer(
  lay_DOY ~ mean_temp_30 * rain_days_30 + z_active_nests + (1 | year),
  data = timing_weather_30_cc_pop,
  REML = FALSE
)

# ---------------------------
# 2) Extend candidate list
# ---------------------------
cand_timing_30_extended <- c(
  cand_timing_30,
  list(
    pop_only = m_pop_only,
    best_pop = m_best_pop
  )
)

# ---------------- helpers ----------------
dev_m2ll <- function(mod) -2 * as.numeric(logLik(mod))
get_K <- function(mod) attr(logLik(mod), "df")

vc_year <- function(mod) {
  if (is.null(mod)) return(NA_real_)
  vc <- as.data.frame(VarCorr(mod))
  out <- vc$vcov[vc$grp == "year"][1]
  if (length(out) == 0) NA_real_ else out
}

# baseline year variance from null model (must exist)
v0 <- vc_year(cand_timing_30_extended$null_re)

annual_var_expl <- function(mod){
  v_mod <- vc_year(mod)
  if (is.finite(v_mod) && is.finite(v0) && v0 > 0) {
    max(0, (v0 - v_mod) / v0)   # <- key change: proportion of variance REDUCED
  } else {
    NA_real_
  }
}

slope_se_single <- function(mod, digits = 3){
  if (is.null(mod)) return("")
  fe <- fixef(mod)
  if (length(fe) == 2) {
    cf <- summary(mod)$coefficients
    paste0(round(cf[2,1], digits), " (", round(cf[2,2], digits), ")")
  } else ""
}

build_obj3_base <- function(cand_list) {
  bind_rows(lapply(names(cand_list), function(nm){
    mod <- cand_list[[nm]]
    tibble(
      model_id = nm,
      K = get_K(mod),
      Deviance = dev_m2ll(mod),
      AICc = AICcmodavg::AICc(mod),
      `Annual variance explained` = annual_var_expl(mod),
      `slope (SE)` = slope_se_single(mod)
    )
  })) %>%
    arrange(AICc) %>%
    mutate(
      `ΔAICc` = AICc - min(AICc, na.rm = TRUE),
      w = exp(-0.5 * `ΔAICc`) / sum(exp(-0.5 * `ΔAICc`)),
      Deviance = round(Deviance, 2),
      AICc = round(AICc, 2),
      `ΔAICc` = round(`ΔAICc`, 2),
      w = round(w, 3),
      `Annual variance explained` = round(`Annual variance explained`, 3)
    )
}

# ---------------------------
# 3) Model key (MATCH your cand_timing_30)
# + add pop rows
# ---------------------------
model_key <- tibble::tribble(
  ~model_id,      ~Group,                      ~Model,
  "null_re",      "Baseline",                  "Intercept only",

  "meanT_30",     "Temperature",               "Mean temperature (30 days)",
  "maxT_30",      "Temperature",               "Maximum temperature (30 days)",
  "minT_30",      "Temperature",               "Minimum temperature (30 days)",

  "rainDays_30",  "Rain",                      "Rainy days (30 days)",
  "totalR_30",    "Rain",                      "Total rainfall (30 days)",

  "meanW_30",     "Wind",                      "Mean wind speed (30 days)",
  "maxW_30",      "Wind",                      "Maximum wind speed (30 days)",

  "lagMeanT",     "Lagged effects",            "Previous year's mean temperature",
  "lagTotR",      "Lagged effects",            "Previous year's total rainfall",
  "lagRainD",     "Lagged effects",            "Previous year's rainy days",

  "temp_rain",    "Joint effects",             "Mean temperature + rainy days",
  "temp_x_rain",  "Interactive effects",       "Mean temperature × rainy days",

  "pop_only",     "Population size (post hoc)","Population size (z active nests)",
  "best_pop",     "Population size (post hoc)","Best model + population size"
)

# ---------------------------
# 4) Build df for flextable
# ---------------------------
group_order <- c(
  "Baseline","Temperature","Rain","Wind","Lagged effects",
  "Joint effects","Interactive effects",
  "Population size (post hoc)",
  "Other"
)

df <- build_obj3_base(cand_timing_30_extended) %>%
  left_join(model_key, by = "model_id") %>%
  mutate(
    Group = coalesce(Group, "Other"),
    Model = coalesce(Model, model_id),
    Group = factor(Group, levels = group_order)
  ) %>%
  arrange(Group, `ΔAICc`) %>%
  transmute(
    Group, Model, K, Deviance, AICc, `ΔAICc`, w,
    `Annual variance explained`, `slope (SE)`
  )

groups <- df %>%
  dplyr::filter(!is.na(Group)) %>%
  dplyr::pull(Group) %>%
  unique() %>%
  as.character()
if (nrow(df) == 0) {
  stop("Table dataframe is empty: model_id mismatch between cand_timing_30_extended and model_key")
}
make_group_block <- function(g) {
  header <- df[0, ]
  header[1, ] <- NA
  header$Group <- g
  header$Model <- g
  header$is_group <- TRUE

  rows <- df %>% filter(as.character(Group) == g)
  rows$is_group <- FALSE
  bind_rows(header, rows)
}

df2 <- bind_rows(lapply(groups, make_group_block))
group_rows <- which(df2$is_group)
df_print <- df2 %>% dplyr::select(-Group, -is_group)

# ---------------------------
# 5) Flextable styling
# ---------------------------
ft <- flextable(df_print) %>%
  font(fontname = "Times New Roman", part = "all") %>%
  fontsize(size = 12, part = "all") %>%
  bold(part = "header") %>%
  bg(part = "header", bg = "#f2f2f2") %>%
  align(j = 1, align = "left", part = "all") %>%
  align(j = 2:ncol(df_print), align = "center", part = "all") %>%
  bg(i = group_rows, bg = "#e6e6e6", part = "body") %>%
  bold(i = group_rows, part = "body") %>%
  autofit()

for (r in group_rows) {
  ft <- merge_at(ft, i = r, j = 1:ncol(df_print), part = "body")
  ft <- align(ft, i = r, j = 1, align = "left", part = "body")
}

# ---------------------------
# 6) Export to Word
# ---------------------------
doc <- read_docx() %>%
  body_add_par(
    paste0(
      "Table 3. Model selection results for breeding timing (laying date, day of year) using 30-day pre-laying weather cues. ",
      "Models were fitted using linear mixed-effects models with year as a random intercept. ",
      "K = number of parameters; Deviance = -2 log-likelihood; AICc = small-sample AIC; ΔAICc = difference from the best model; w = Akaike weight. ",
      "Annual variance explained is the proportional reduction in the year random-intercept variance relative to the null model. ",
      "Slope (SE) is shown for single-predictor models only. ",
      "Population size models were fitted post hoc and are shown for comparison."
    ),
    style = "Normal"
  ) %>%
  body_add_flextable(ft)

print(doc, target = "Table_Breeding_Timing_30day.docx")
```



```{r}
# Figure 3: Predicted laying date from the best timing model (mean_temp_30 × rain_days_30)
library(ggplot2)
library(dplyr)
library(lme4)

# --- 1) Grab your fitted model ---
# Assumes your best model is stored as cand_timing_30$temp_x_rain (as in your scripts)
stopifnot(exists("cand_timing_30"))
stopifnot("temp_x_rain" %in% names(cand_timing_30))
mod <- cand_timing_30$temp_x_rain

# --- 2) Use the model frame to get ranges (avoids mismatches) ---
mf <- model.frame(mod)

# If your columns are named differently inside the model, stop early with a clear message
stopifnot(all(c("mean_temp_30", "rain_days_30") %in% names(mf)))

# --- 3) Build a prediction grid ---
temp_seq <- seq(min(mf$mean_temp_30, na.rm = TRUE),
                max(mf$mean_temp_30, na.rm = TRUE),
                length.out = 120)

rain_q <- as.numeric(quantile(mf$rain_days_30, probs = c(0.10, 0.50, 0.90), na.rm = TRUE))
rain_lab <- c(
  paste0("Low (P10 = ", round(rain_q[1], 1), ")"),
  paste0("Med (P50 = ", round(rain_q[2], 1), ")"),
  paste0("High (P90 = ", round(rain_q[3], 1), ")")
)

newdat <- expand.grid(
  mean_temp_30 = temp_seq,
  rain_days_30 = rain_q
) %>%
  mutate(rain_group = factor(rep(rain_lab, each = length(temp_seq)),
                             levels = rain_lab))

# --- 4) Predict fixed-effects only + 95% CI (analytical, no bootstrap) ---
tt <- delete.response(terms(mod))
X  <- model.matrix(tt, newdat)
beta <- fixef(mod)
V <- as.matrix(vcov(mod))

newdat$fit <- as.numeric(X %*% beta)
newdat$se  <- sqrt(diag(X %*% V %*% t(X)))
newdat$lwr <- newdat$fit - 1.96 * newdat$se
newdat$upr <- newdat$fit + 1.96 * newdat$se

# --- 5) Plot ---
p <- ggplot(newdat, aes(x = mean_temp_30, y = fit, group = rain_group)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr, fill = rain_group), alpha = 0.20, colour = NA) +
  geom_line(aes(colour = rain_group), linewidth = 1) +
  labs(
    x = "Mean temperature (30-day pre-laying period)",
    y = "Predicted laying date (DOY)",
    colour = "Rainy days (30-day period)",
    fill   = "Rainy days (30-day period)"
  ) +
  theme_classic(base_family = "Times New Roman") +
  theme(
    panel.grid = element_blank(),
    legend.position = "right"
  )

p
```


```{r}
library(dplyr)
library(tidyr)
library(lme4)
library(AICcmodavg)

timing_weather_30_cc_pop <- timing_weather_30 %>%
  mutate(year = factor(year)) %>%
  dplyr::select(
    lay_DOY, year,
    mean_temp_30, rain_days_30,
    z_active_nests
  ) %>%
  tidyr::drop_na()
```

```{r}
m_pop_only <- lmer(
  lay_DOY ~ z_active_nests + (1 | year),
  data = timing_weather_30_cc_pop,
  REML = FALSE
)

m_best_pop <- lmer(
  lay_DOY ~ mean_temp_30 * rain_days_30 + z_active_nests + (1 | year),
  data = timing_weather_30_cc_pop,
  REML = FALSE
)
```



```{r}
vc_year <- function(mod) {
  vc <- as.data.frame(VarCorr(mod))
  out <- vc$vcov[vc$grp == "year"][1]
  if (length(out) == 0) NA_real_ else out
}

v0_time <- vc_year(cand_timing_30$null_re)
v0_time
```


```{r}
ggplot(timing_weather_60, aes(x = lay_DOY)) +
  geom_histogram(bins = 15, fill = "grey70", colour = "black") +
  labs(
    x = "Laying date (day of year)",
    y = "Frequency",
    title = "Distribution of laying dates"
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())

```

```{r}
timing_weather_30_filt <- timing_weather_30 |>
  dplyr::filter(year >= 1993, year <= 2024)

ggplot(timing_weather_30_filt, aes(x = year, y = lay_DOY)) +
  geom_point(
    size = 1.8,
    colour = "grey30",
    alpha = 0.6
  ) +
  geom_smooth(
    method = "lm",
    se = TRUE,
    colour = "grey",
    linewidth = 1
  ) +
  scale_x_continuous(
    breaks = seq(1995, 2025, by = 5),
    limits = c(1993, 2024)
  ) +
  labs(
    x = "Year",
    y = "Laying date (day of year)",
    title = "Annual variation in laying date at Dronfield"
  ) +
  theme_bw() +
  theme(
    panel.grid = element_blank()
  )+
  geom_jitter(
  width = 0.2,
  height = 0,
  size = 1.6,
  colour = "grey30",
  alpha = 0.6
)



```

```{r}

library(dplyr)
library(ggplot2)
library(lme4)

# --- assumes you already have:
# df    = your observed data frame (with mean_temp_30, lay_DOY, rain_days_30)
# newdat = your prediction grid (with mean_temp_30, lo, hi, fit, and some rain grouping column)

# 1) Make sure df is the same data used in the model (recommended)
# If you have the model object, this is safest:
# m_int <- cand_timing_30$temp_x_rain
# df <- model.frame(m_int)

# 2) Ensure newdat has a Rain_group column (robust)
if (!"Rain_group" %in% names(newdat)) {
  if ("Rainfall" %in% names(newdat)) {
    newdat$Rain_group <- newdat$Rainfall
  } else if ("rain_group" %in% names(newdat)) {
    newdat$Rain_group <- newdat$rain_group
  } else if ("rain_days_30" %in% names(newdat)) {
    newdat$Rain_group <- factor(newdat$rain_days_30)
  } else {
    stop("newdat doesn't contain Rain_group, Rainfall, rain_group, or rain_days_30 — check names(newdat).")
  }
}
newdat$Rain_group <- as.factor(newdat$Rain_group)

# 3) Zoom y-axis to reduce outlier-driven whitespace (does NOT drop data)
y_zoom <- quantile(df$lay_DOY, probs = c(0.02, 0.98), na.rm = TRUE)

# 4) Plot
ggplot() +
  geom_point(
    data = df,
    aes(x = mean_temp_30, y = lay_DOY),
    colour = "#B1BD8C",
    alpha = 0.18,
    size = 1.4
  ) +
  geom_ribbon(
    data = newdat,
    aes(x = mean_temp_30, ymin = lo, ymax = hi, group = Rain_group),
    fill = "#D5D6D2",
    alpha = 0.12
  ) +
  geom_line(
    data = newdat,
    aes(x = mean_temp_30, y = fit, linetype = Rain_group, group = Rain_group),
    colour = "#9FA19A",
    linewidth = 1.2
  ) +
  coord_cartesian(ylim = y_zoom) +
  labs(
    x = "Mean temperature (30 days pre-laying)",
    y = "Laying date (day of year)",
    linetype = "Rainfall conditions"
  ) +
  theme_bw(base_family = "Times New Roman") +
  theme(
    panel.grid = element_blank(),
    axis.title = element_text(face = "bold", size = 12),
    axis.text  = element_text(face = "bold", size = 12),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.title = element_text(face = "bold", size = 12),
    legend.text  = element_text(size = 11)
  )
```
Laying date advanced with increasing pre-laying temperature, but this effect was contingent on rainfall conditions, indicating that thermal cues did not operate independently of broader environmental context. 



```{r}
library(dplyr)
library(ggplot2)
library(forcats)


model_labels <- tibble::tribble(
  ~model_id,      ~label_short,
  "meanT_30",     "Mean T (30d)",
  "maxT_30",      "Max T (30d)",
  "minT_30",      "Min T (30d)",
  "rainDays_30",  "Rain days (30d)",
  "totalR_30",    "Total rain (30d)",
  "meanW_30",     "Mean wind (30d)",
  "maxW_30",      "Max wind (30d)",

  "meanT_60",     "Mean T (60d)",
  "maxT_60",      "Max T (60d)",
  "minT_60",      "Min T (60d)",
  "rainDays_60",  "Rain days (60d)",
  "totalR_60",    "Total rain (60d)",
  "meanW_60",     "Mean wind (60d)",
  "maxW_60",      "Max wind (60d)",

  "lagTotR",      "Lag total rain",
  "lagRainD",     "Lag rain days",
  "lagMeanT",     "Lag mean T",

  "temp_rain",    "Mean T + rain days",
  "temp_wind",    "Mean T + mean wind",
  "rain_wind",    "Rain days + mean wind",

  "temp_x_rain",  "Mean T × rain days",
  "minT_x_wind",  "Min T × mean wind",
  "lagR_x_temp",  "Lag rain × mean T"
)

plot_daic <- function(cand_list, period_label){
  tab <- build_obj3_base(cand_list) |>
    left_join(model_labels, by = "model_id") |>
    mutate(
      label_short = coalesce(label_short, model_id),
      is_best = (`ΔAICc` == min(`ΔAICc`)),
      label_short = fct_reorder(label_short, `ΔAICc`, .desc = FALSE)

    )

  ggplot(tab, aes(x = label_short, y = `ΔAICc`, fill = is_best)) +
    geom_col(width = 0.75) +
    coord_flip() +
    scale_fill_manual(values = c(`TRUE` = "steelblue", `FALSE` = "grey70"), guide = "none") +
    geom_hline(yintercept = 2, linetype = "dashed") +
    labs(
      x = NULL,
      y = expression(Delta*AIC[c]),
      title = paste0("Objective 3: Model support (", period_label, ")"),
      subtitle = "Dashed line = ΔAICc = 2 (models with substantial support)"
    ) +
    theme_bw() +
    theme(panel.grid = element_blank())
}

p_daic_30 <- plot_daic(cand_timing_30, "30-day cues")
p_daic_60 <- plot_daic(cand_timing_60, "60-day cues")

p_daic_30
p_daic_60


```





```{r}
library(dplyr)
library(ggplot2)

plot_temp_rain_clean <- function(model, data,
                                 xvar = "mean_temp_30",
                                 zvar = "rain_days_30",
                                 yvar = "lay_DOY",
                                 period_label = "30-day cues",
                                 zoom_y = TRUE){


  qs <- quantile(data[[zvar]], probs = c(0.2, 0.5, 0.8), na.rm = TRUE)

  grid <- expand.grid(
    x = seq(min(data[[xvar]], na.rm = TRUE), max(data[[xvar]], na.rm = TRUE), length.out = 100),
    z = qs
  )
  names(grid) <- c(xvar, zvar)

  grid$pred <- predict(model, newdata = grid)
  grid$rain_level <- factor(
    c("Low rain", "Medium rain", "High rain")[match(grid[[zvar]], qs)],
    levels = c("Low rain", "Medium rain", "High rain")
  )

  p <- ggplot(data, aes(x = .data[[xvar]], y = .data[[yvar]])) +
    geom_point(size = 1.6, alpha = 0.35, colour = "grey25") +
    geom_line(
      data = grid,
      aes(x = .data[[xvar]], y = pred, linetype = rain_level),
      linewidth = 1.1,
      colour = "black"
    ) +
    scale_linetype_manual(values = c("solid", "dashed", "dotdash")) +
    labs(
      title = paste0("Breeding timing  (", period_label, ")"),
      subtitle = "Predicted laying date across temperature at low / medium / high rainfall",
      x = "Mean temperature (30 days prior)",
      y = "Laying date (DOY)",
      linetype = NULL
    ) +
    theme_bw() +
    theme(
      panel.grid = element_blank(),
      plot.title = element_text(size = 12, face = "bold"),
      plot.subtitle = element_text(size = 9),
      axis.title = element_text(size = 9),
      axis.text = element_text(size = 9),
      legend.position = "bottom",
      legend.box = "horizontal"
    )

  if (zoom_y) {
    yl <- quantile(data[[yvar]], probs = c(0.02, 0.98), na.rm = TRUE)
    p <- p + coord_cartesian(ylim = yl)
  }

  p
}


plot_temp_rain_clean(
  model = cand_timing_30$temp_x_rain,
  data  = timing_weather_30,
  xvar  = "mean_temp_30",
  zvar  = "rain_days_30",
  period_label = "30-day cues",
  zoom_y = TRUE
)

```

```{r}
library(dplyr)
library(ggplot2)

plot_temp_rain_clean <- function(model, data,
                                 xvar,
                                 zvar,
                                 yvar = "lay_DOY",
                                 period_label = "",
                                 xlab = NULL,
                                 zlab = NULL,
                                 zoom_y = TRUE){

  dd <- data |>
    dplyr::filter(
      !is.na(.data[[xvar]]),
      !is.na(.data[[zvar]]),
      !is.na(.data[[yvar]])
    )

  qs <- quantile(dd[[zvar]], probs = c(0.2, 0.5, 0.8), na.rm = TRUE)

  grid <- expand.grid(
    x = seq(min(dd[[xvar]], na.rm = TRUE), max(dd[[xvar]], na.rm = TRUE), length.out = 100),
    z = qs
  )
  names(grid) <- c(xvar, zvar)

  grid$pred <- predict(model, newdata = grid)

  z_show <- ifelse(is.null(zlab), zvar, zlab)
  grid$level <- factor(
    c("Low", "Medium", "High")[match(grid[[zvar]], qs)],
    levels = c("Low", "Medium", "High")
  )

  p <- ggplot(dd, aes(x = .data[[xvar]], y = .data[[yvar]])) +
    geom_point(size = 1.6, alpha = 0.35, colour = "grey25") +
    geom_line(
      data = grid,
      aes(x = .data[[xvar]], y = pred, linetype = level),
      linewidth = 1.1,
      colour = "black"
    ) +
    scale_linetype_manual(
      values = c("solid", "dashed", "dotdash"),
      labels = paste0(levels(grid$level), " ", z_show)
    ) +
    labs(
      title = paste0("Breeding timing (", period_label, ")"),
      subtitle = "Predicted laying date across temperature at low / medium / high rainfall",
      x = ifelse(is.null(xlab), xvar, xlab),
      y = "Laying date (DOY)",
      linetype = NULL
    ) +
    theme_bw() +
    theme(
      panel.grid = element_blank(),
      plot.title = element_text(size = 12, face = "bold"),
      plot.subtitle = element_text(size = 9),
      axis.title = element_text(size = 9),
      axis.text = element_text(size = 9),
      legend.position = "bottom",
      legend.box = "horizontal"
    )

  if (zoom_y) {
    yl <- quantile(dd[[yvar]], probs = c(0.02, 0.98), na.rm = TRUE)
    p <- p + coord_cartesian(ylim = yl)
  }

  p
}


p_timing_30 <- plot_temp_rain_clean(
  model = cand_timing_30$temp_x_rain,
  data  = timing_weather_30,
  xvar  = "mean_temp_30",
  zvar  = "rain_days_30",
  period_label = "30-day cues",
  xlab = "Mean temperature (30 days prior)",
  zlab = "Rainy days (30 days prior)",
  zoom_y = TRUE
)


p_timing_60 <- plot_temp_rain_clean(
  model = cand_timing_60$temp_x_rain,
  data  = timing_weather_60,
  xvar  = "mean_temp_60",
  zvar  = "rain_days_60",
  period_label = "60-day cues",
  xlab = "Mean temperature (60 days prior)",
  zlab = "Rainy days (60 days prior)",
  zoom_y = TRUE
)

p_timing_30
p_timing_60

```

### Simulation 

```{r}
set.seed(1)

simulate_b <- function(
  n_years = 32,
  nests_per_year = 60,
  beta_WT = -4,      # W -> T 
  beta_WS = 1.0,     # W -> S 
  sigma_T = 8,       # spread of lay dates within a year
  year_sd = 4        # add between-year timing variation
){

  years <- 1:n_years

  # year-level w
  W_y <- rnorm(n_years, 0, 1)

  # unobserved between-yea
  u_y <- rnorm(n_years, 0, year_sd)

  dat <- do.call(rbind, lapply(years, function(y){
    W <- W_y[y]
    u <- u_y[y]

    # true timing 
    T <- 170 + beta_WT * W + u + rnorm(nests_per_year, 0, sigma_T)

    # success depends on weather 
    eta <- 0.5 + beta_WS * W
    pS  <- plogis(eta)
    S   <- rbinom(nests_per_year, 1, pS)

    # observed timing only if success
    Tstar <- ifelse(S == 1, T, NA_real_)

    data.frame(
      year = y,
      W = W,
      T = T,
      S = S,
      Tstar = Tstar
    )
  }))

  fit_obs <- lm(Tstar ~ W, data = dat)

  fit_true <- lm(T ~ W, data = dat)

  list(
    dat = dat,
    beta_hat_obs  = coef(fit_obs)[["W"]],
    beta_hat_true = coef(fit_true)[["W"]],
    fit_obs = fit_obs,
    fit_true = fit_true
  )
}

#run 1
out <- simulate_b(beta_WT = -4, beta_WS = 1.5)
out$beta_hat_true
out$beta_hat_obs

```
```{r}
set.seed(3)
runs <- 1000
res <- replicate(runs, {
  o <- simulate_b(beta_WT = -4, beta_WS = 1.5)
  o$beta_hat_obs - o$beta_hat_true
})
quantile(res, c(0.025, 0.5, 0.975))
mean(res)

```

```{r}
library(dplyr)

success_df <- success_df |>
  mutate(year = as.integer(as.character(year)))

timing_weather_30 <- timing_weather_30 |>
  mutate(year = as.integer(year))

timing_weather_30 <- timing_weather_30 |>
  left_join(
    success_df |>
      dplyr::select(year, active_nests) |>
      dplyr::distinct(),
    by = "year"
  ) |>
  mutate(z_active_nests = as.numeric(scale(active_nests)))



# best 30-day model
m_time30_best <- cand_timing_30$temp_x_rain

# add population size
m_time30_best_pop <- lm(
  lay_DOY ~ mean_temp_30 * rain_days_30 + z_active_nests,
  data = timing_weather_30
)

# compare
summary(m_time30_best)
summary(m_time30_best_pop)

AICcmodavg::aictab(list(
  best      = m_time30_best,
  best_pop  = m_time30_best_pop
))

summary(m_time30_best)$r.squared
summary(m_time30_best_pop)$r.squared

```

```{r}
library(dplyr)
library(tibble)
library(AICcmodavg)
library(flextable)
library(officer)


timing_weather_30 <- timing_weather_30 |>
  mutate(year = as.integer(year))

success_df <- success_df |>
  mutate(year = as.integer(as.character(year)))


# candidate column names 
cand_cols <- c("active_nests", "ActiveNests", "n_active_nests", "active", "nests", "n_nests")

# CASE A: timing_weather_30 already has active_nests
if ("active_nests" %in% names(timing_weather_30)) {

  timing_weather_30 <- timing_weather_30 |>
    mutate(z_active_nests = as.numeric(scale(.data[["active_nests"]])))

} else {

  # find a nest column in success_df
  pop_col <- intersect(cand_cols, names(success_df))[1]

  if (is.na(pop_col) || length(pop_col) == 0) {
    stop(
      "Couldn't find an active-nests / population-size column. ",
      "Looked for: ", paste(cand_cols, collapse = ", "),
      ". Available in success_df: ", paste(names(success_df), collapse = ", ")
    )
  }

  success_pop <- success_df |>
    select(year, !!rlang::sym(pop_col)) |>
    distinct() |>
    rename(active_nests = !!rlang::sym(pop_col))

  timing_weather_30 <- timing_weather_30 |>
    left_join(success_pop, by = "year") |>
    mutate(z_active_nests = as.numeric(scale(.data[["active_nests"]])))
}


if (all(is.na(timing_weather_30$z_active_nests))) {
  stop("z_active_nests is all NA after join/scale — check that year values match between datasets.")
}

m_time30_best <- cand_timing_30$temp_x_rain

m_time30_pop <- lm(
  lay_DOY ~ z_active_nests,
  data = timing_weather_30
)

m_time30_best_pop <- lm(
  lay_DOY ~ mean_temp_30 * rain_days_30 + z_active_nests,
  data = timing_weather_30
)


sens_tbl <- tibble(
  Model = c(
    "Mean temperature × rainy days",
    "Population size",
    "Mean temperature × rainy days + population size"
  ),
  AICc = c(
    AICc(m_time30_best),
    AICc(m_time30_pop),
    AICc(m_time30_best_pop)
  ),
  R2 = c(
    summary(m_time30_best)$r.squared,
    summary(m_time30_pop)$r.squared,
    summary(m_time30_best_pop)$r.squared
  )
) |>
  mutate(
    `ΔAICc` = AICc - min(AICc),
    w = exp(-0.5 * `ΔAICc`) / sum(exp(-0.5 * `ΔAICc`)),
    `ΔAICc` = round(`ΔAICc`, 2),
    w = round(w, 2),
    R2 = round(R2, 2)
  ) |>
  select(Model, `ΔAICc`, w, `R²` = R2)

ft <- flextable(sens_tbl) |>
  font(fontname = "Times New Roman", part = "all") |>
  fontsize(size = 12, part = "all") |>
  bold(part = "header") |>
  bg(part = "header", bg = "#f2f2f2") |>
  align(j = 1, align = "left", part = "all") |>
  align(j = 2:ncol(sens_tbl), align = "center", part = "all") |>
  autofit()

doc <- read_docx() |>
  body_add_par(
    "Table X. assessing whether breeding population size improves model fit when added to the best-supported weather-based timing model (30-day pre-laying cues). ΔAICc values are relative to the best-supported model.",
    style = "Normal"
  ) |>
  body_add_flextable(ft)

print(doc, target = "Table_Obj3_Timing_Population_Sensitivity.docx")

```

```{r}
library(dplyr)
library(ggplot2)

newdat <- tibble(
  z_active_nests = seq(
    min(timing_weather_30$z_active_nests, na.rm = TRUE),
    max(timing_weather_30$z_active_nests, na.rm = TRUE),
    length.out = 120
  ),
  mean_temp_30 = mean(timing_weather_30$mean_temp_30, na.rm = TRUE),
  rain_days_30 = mean(timing_weather_30$rain_days_30, na.rm = TRUE)
)

pred <- predict(m_time30_best_pop, newdata = newdat, se.fit = TRUE)
newdat <- newdat |>
  mutate(
    fit = pred$fit,
    lo  = pred$fit - 1.96 * pred$se.fit,
    hi  = pred$fit + 1.96 * pred$se.fit
  )


ggplot(timing_weather_30, aes(x = z_active_nests, y = lay_DOY)) +
  geom_point(
    colour = "grey60",
    alpha = 0.35,
    size = 1.6
  ) +
  geom_ribbon(
    data = newdat,
    aes(x = z_active_nests, ymin = lo, ymax = hi),
    inherit.aes = FALSE,
    alpha = 0.15
  ) +
  geom_line(
    data = newdat,
    aes(x = z_active_nests, y = fit),
    inherit.aes = FALSE,
    linewidth = 1.3,
    colour = "black"
  ) +
  labs(
    x = "Breeding population size (standardised)",
    y = "Laying date (day of year)",
    title = "Population size effect on laying date",
    subtitle = "Predictions from the best-supported weather model (30-day cues);\nmean temperature and rainy days held at their mean values"
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())

```


## DAGs

```{r}
#install.packages("ggdag")
#install.packages("dagitty")
#install.packages(rsvg)


library(ggdag)
library(dagitty)
library(DiagrammeR)
library(rsvg)
library(DiagrammeRsvg)



```


### Objective 3: Breeding Timing - missing data

### Scenario A

```{r}
library(DiagrammeR)
library(DiagrammeRsvg)
library(knitr)
library(rsvg)

timing_simple_dag <- grViz("
digraph timing_simple {
  graph [
    layout = neato,
    splines = false,
    overlap = false
  ]

  node [
    fontname = Helvetica,
    fontsize = 22,
    penwidth = 2,
    margin = 0.25
  ]

  edge [
    penwidth = 1.8,
    arrowsize = 0.55
  ]

  W     [label = 'W',  shape = box,    pos = '1.4,1.5!']

  T [label = 'T',
     shape = circle,
     fixedsize = true,
     width = 1,
     pos = '2.8,1.5!'
  ]

  S     [label = 'S',  shape = box,    pos = '1.4,0!']
  Tstar [label = 'T*', shape = box,    pos = '2.8,0!']

  W -> T
  T -> Tstar
  S -> Tstar
}
")

# make a figures folder if it doesn't exist
dir.create("figures", showWarnings = FALSE)

# export SVG text from the DAG
svg_txt <- DiagrammeRsvg::export_svg(timing_simple_dag)

# convert SVG -> PDF
rsvg_pdf(
  charToRaw(svg_txt),
  file   = "figures/timing_simple_dag.pdf",
  width  = 8,
  height = 4
)

# sanity check
file.info("figures/timing_simple_dag.pdf")[, c("size")]
```

In this scenario, weather (W) does not affect breeding success (S), meaning that success is effectively random with respect to the weather variable used to explain breeding timing. As a result, success does not act as a confounder, and analysing observed timing (T*) yields the correct inference about the effect of weather on timing. This situation is plausible if breeding success is driven mainly by conditions later in the breeding season, rather than by the pre-breeding weather cues that influence the initiation of breeding.

### Scenario B

```{r}
library(DiagrammeR)
library(DiagrammeRsvg)
library(rsvg)

# ensure figures folder exists
dir.create("figures", showWarnings = FALSE)

timing_B_dag <- grViz("
digraph timing_B {
  graph [
    layout = neato,
    splines = false,
    overlap = false
  ]

  node [
    fontname = Helvetica,
    fontsize = 22,
    penwidth = 2,
    margin = 0.25
  ]

  edge [
    penwidth = 1.8,
    arrowsize = 0.55
  ]

  W     [label = 'W',  shape = box,    pos = '1.0,1.5!']

  T [label = 'T',
     shape = circle,
     fixedsize = true,
     width = 1,
     pos = '2.8,1.5!'
  ]

  S     [label = 'S',  shape = box,    pos = '1.0,0!']
  Tstar [label = 'T*', shape = box,    pos = '2.8,0!']

  W -> T
  W -> S
  T -> Tstar
  S -> Tstar
}
")

# export SVG text
svg_txt <- DiagrammeRsvg::export_svg(timing_B_dag)

# convert SVG -> PDF (REAL PDF)
rsvg::rsvg_pdf(
  charToRaw(svg_txt),
  file   = "figures/timing_B_dag.pdf",
  width  = 8,
  height = 4
)

# sanity check
file.info("figures/timing_B_dag.pdf")[, "size"]


```

In scenario (b), the same weather variable (W) influences both breeding timing (T) and breeding success (S), but timing itself does not causally affect success. In this case, success is associated with weather, and observed timing (T^) is therefore indirectly linked to weather through both pathways. However, because success is not a mediator of the weather–timing relationship, analysing T* can still recover the underlying effect of weather on timing, particularly when effects are approximately linear. The simulation results suggest that under this structure, any bias introduced by observing timing only for successful nests is small and unlikely to alter biological interpretation.


### Scenario C

```{r}
library(DiagrammeR)
library(DiagrammeRsvg)
library(rsvg)

dir.create("figures", showWarnings = FALSE)

timing_C_dag <- grViz("
digraph timing_C {
  graph [
    layout = neato,
    splines = false,
    overlap = false
  ]

  node [
    fontname = Helvetica,
    fontsize = 22,
    penwidth = 2,
    margin = 0.25
  ]

  edge [
    penwidth = 1.8,
    arrowsize = 0.55
  ]

  W     [label = 'W',  shape = box,    pos = '1.0,1.5!']

  T [label = 'T',
     shape = circle,
     fixedsize = true,
     width = 1,
     pos = '2.8,1.5!'
  ]

  S     [label = 'S',  shape = box,    pos = '1.0,0!']
  Tstar [label = 'T*', shape = box,    pos = '2.8,0!']

  W -> T
  T -> Tstar
  S -> Tstar
  T -> S
}
")

svg_txt <- DiagrammeRsvg::export_svg(timing_C_dag)

rsvg::rsvg_pdf(
  charToRaw(svg_txt),
  file   = "figures/timing_C_dag.pdf",
  width  = 8,
  height = 4
)

# sanity check
file.info("figures/timing_C_dag.pdf")[, "size"]

``` 
In scenario (c), breeding timing directly influences breeding success, in addition to weather affecting timing. Under this structure, it is no longer possible to disentangle whether an apparent effect of weather on observed timing reflects a direct causal effect on breeding initiation or an indirect effect mediated through success. In this case, inference is limited to the timing of successful nests only. Although this scenario may seem plausible at first, it is less clear at the interannual scale considered here, as selection on early or late breeding within a season does not necessarily imply that years with earlier or later average breeding are associated with higher or lower overall breeding success.

### Scenario D

```{r}
library(DiagrammeR)
library(DiagrammeRsvg)
library(rsvg)

dir.create("figures", showWarnings = FALSE)

timing_D_dag <- grViz("
digraph timing_D {
  graph [
    layout = neato,
    splines = false,
    overlap = false
  ]

  node [
    fontname = Helvetica,
    fontsize = 22,
    penwidth = 2,
    margin = 0.25
  ]

  edge [
    penwidth = 1.8,
    arrowsize = 0.55
  ]

  W     [label = 'W',  shape = box,    pos = '1.0,1.5!']

  T [label = 'T',
     shape = circle, 
     fixedsize = true,
     width = 1,
     pos = '2.8,1.5!'
  ]

  S     [label = 'S',  shape = box,    pos = '1.0,0!']
  Tstar [label = 'T*', shape = box,    pos = '2.8,0!']

  X [label = 'X',
     shape = circle,
     fixedsize = true,
     width = 0.9,
     pos = '2.0,0.75!'
  ]

  W -> T
  T -> Tstar
  S -> Tstar
  X -> T
  X -> S
}
")

svg_txt <- DiagrammeRsvg::export_svg(timing_D_dag)

rsvg::rsvg_pdf(
  charToRaw(svg_txt),
  file   = "figures/timing_D_dag.pdf",
  width  = 8,
  height = 4
)

# sanity check
file.info("figures/timing_D_dag.pdf")[, "size"]

```

In scenario (d), an unobserved variable (X), representing colony state or population size, influences both breeding timing (T) and breeding success (S). In this case, population-level processes such as density dependence, food competition, or overall adult condition could shift both when breeding is initiated and the likelihood of breeding success. Because X affects both timing and success, it acts as a confounder, and the effect of weather on observed timing (T*) cannot be cleanly isolated without accounting for this shared influence. If a suitable proxy for colony size or population state were available, including it in the analysis could help reduce this source of bias; otherwise, inference about causal pathways remains uncertain.


--------------------------------------------------------------------------------
### Objective 1: Breeding effort 

### Scenario A
```{r}
library(DiagrammeR)
library(DiagrammeRsvg)
library(rsvg)

dir.create("figures", showWarnings = FALSE)

trend_confounded_dag <- grViz("
digraph trend_confounded {
  graph [
    layout = neato,
    splines = false,
    overlap = false
  ]

  node [
    fontname = Helvetica,
    fontsize = 22,
    penwidth = 2,
    shape = box,
    margin = 0.25
  ]

  edge [
    penwidth = 1.8,
    arrowsize = 0.55
  ]

  Y [label = 'Y', pos = '2.5,2!']
  W [label = 'W', pos = '1.2,0!']
  N [label = 'N', pos = '4.0,0!']

  Y -> W
  Y -> N
  W -> N
}
")

# export SVG text
svg_txt <- DiagrammeRsvg::export_svg(trend_confounded_dag)

# convert SVG -> PDF
rsvg::rsvg_pdf(
  charToRaw(svg_txt),
  file   = "figures/trend_confounded_dag.pdf",
  width  = 6,
  height = 5
)

# sanity check
file.info("figures/trend_confounded_dag.pdf")[, "size"]


```
in this scenario, the temporal trend (Y) directly influences both weather (W) and breeding effort (B). Because Y affects both variables, it acts as a confounder of the weather–breeding relationship. To estimate the direct effect of weather on breeding effort, it is therefore necessary to control for Y in the analysis.

### Scenario B

```{r}
library(DiagrammeRsvg)
library(rsvg)

dir.create("figures", showWarnings = FALSE)

export_dag_pdf <- function(dag, filename, w = 8, h = 4) {
  svg_txt <- DiagrammeRsvg::export_svg(dag)
  rsvg::rsvg_pdf(charToRaw(svg_txt),
                 file = file.path("figures", filename),
                 width = w, height = h)
  file.info(file.path("figures", filename))[, "size"]
}

# re-export active-nests DAGs to match timing DAG size (8 x 4)
export_dag_pdf(trend_confounded_dag, "trend_confounded_dag.pdf", 8, 4)
export_dag_pdf(trend_W_B_dag,        "trend_W_B_dag.pdf",        8, 4)
export_dag_pdf(trend_mediator_dag,   "trend_mediator_dag.pdf",   8, 4)

```

In this scenario, the temporal trend (Y) influences the weather variable (W), which in turn affects breeding (B). There is no direct effect of the trend on breeding, meaning that Y is not a confounder of the weather–breeding relationship. As a result, controlling for Y is unnecessary and could obscure the effect of interest, since the influence of Y on breeding operates entirely through weather.

### Scenario c

```{r}


library(DiagrammeR)
library(DiagrammeRsvg)
library(rsvg)

dir.create("figures", showWarnings = FALSE)

trend_mediator_dag <- grViz("
digraph trend_mediator {
  graph [
    layout = neato,
    splines = false,
    overlap = false
  ]

  node [
    fontname = Helvetica,
    fontsize = 22,
    penwidth = 2,
    shape = box,
    margin = 0.25
  ]

  edge [
    penwidth = 1.8,
    arrowsize = 0.55
  ]

  W [label = 'W', pos = '0,0!']
  Y [label = 'Y', pos = '3,0!']
  N [label = 'N', pos = '6,0!']

  W -> Y
  Y -> N
}
")

# export SVG text
svg_txt <- DiagrammeRsvg::export_svg(trend_mediator_dag)

# convert SVG -> PDF
rsvg::rsvg_pdf(
  charToRaw(svg_txt),
  file   = "figures/trend_mediator_dag.pdf",
  width  = 7,
  height = 2.5
)

# sanity check
file.info("figures/trend_mediator_dag.pdf")[, "size"]


```

In this scenario, the temporal trend (Y) acts as a mediator of the weather effect on breeding effort, with weather influencing Y and Y in turn affecting breeding. Because Y lies on the causal pathway between weather and breeding, controlling for Y would block part of the effect of interest. To estimate the total effect of weather on breeding effort, Y should therefore not be included as a control variable.

:::

 


























































































