---
title: "The Effects of Climate Change on the Breeding Success and Timing of African White-backed Vultures"
author: "Mieke Deyzel"
output: html_document
format:
  html:
    embed-resources: true
---
::: {.panel-tabset}
  
## Packages   
 
```{r}
#remotes::install_github("ropensci/rnoaa")
#remotes::install_github("ropensci/chirps")
#install.packages("GSODR")
#install.packages("AICcmodavg")

```

### Load Libraries
```{r}

library(tidyverse)
library(lubridate)
library(janitor)
library(MASS)
library(patchwork)
library(stringr)
library(tibble) 
library(dplyr)
library(knitr)
library(ggplot2)
library(GGally)
library(tidyr)
library(chirps)
library(GSODR)
library(tibble)
library(knitr)
library(AICcmodavg)
library(lme4)


```

### Overdispersion Check 

```{r}
check_overdispersion <- function(model) {
  rp <- residuals(model, type = "pearson")
  disp <- sum(rp^2) / model$df.residual
  disp
} 
```


## Load Data

```{r}
vultures    <- read.csv("~/Desktop/Vulture Project/Data/93_24 cleaned.csv")
# WeatherData <- read.csv("~/Desktop/Vulture Project/Data/Weather.csv")
```

### Weather Data 

```{r}
library(rnoaa)
library(tidyverse)
library(lubridate)

 
kim_station <- "684380-99999"

weather_raw <- get_GSOD(
  station = kim_station,
  years   = 1993:2024
)



```

```{r}
WeatherData <- weather_raw |>
  transmute(
    YEAR,
    MONTH,
    DAY,
    TEMP,
    MAX,
    MIN,
    PRCP,
    WDSP,
    MXSPD,
    I_HAIL
  ) |>
  arrange(YEAR, MONTH, DAY)

```

### CHIRPS Rainfall for 2004 

```{r}
# coordinates  (24.81 E, 28.62 S)

lonlat <- data.frame(
lon = 24.81,
lat = -28.62
)

kimberley_chirps_2004 <- get_chirps(
object   = lonlat,
dates    = c("2004-01-01", "2004-12-31"),
server   = "ClimateSERV",
as.matrix = FALSE
)

glimpse(kimberley_chirps_2004)

```

### CHIRPS Rainfall for 2004 (Dronfield / Kimberley)

```{r}
daily_chirps_2004 <- tibble(
date    = as.Date(kimberley_chirps_2004$date),
rain_mm = as.numeric(kimberley_chirps_2004$chirps)
)

head(daily_chirps_2004) 
summary(daily_chirps_2004$rain_mm)

annual_chirps_2004 <- daily_chirps_2004 |>
mutate(YEAR = year(date)) |>
group_by(YEAR) |>
summarise(
total_rain_2004 = sum(rain_mm, na.rm = TRUE),
max_rain_2004   = max(rain_mm, na.rm = TRUE),
rain_days_2004  = sum(rain_mm > 0, na.rm = TRUE),
.groups = "drop"
)

annual_chirps_2004

```


```{r}
total_rain_2004 <- annual_chirps_2004$total_rain_2004
max_rain_2004   <- annual_chirps_2004$max_rain_2004
rain_days_2004  <- annual_chirps_2004$rain_days_2004

total_rain_2004
max_rain_2004
rain_days_2004

```
### Weather Data 

```{r}
WeatherData_clean <- WeatherData |>
  filter(
    YEAR >= 1993,
    YEAR <= 2024
  ) |>
  mutate(
    date = make_date(YEAR, MONTH, DAY)
  ) |>
  # add CHIRPS daily rainfall into 2004 
  left_join(daily_chirps_2004, by = "date") |>
  mutate(
    PRCP = if_else(YEAR == 2004 & !is.na(rain_mm), rain_mm, PRCP)
  ) |>
  dplyr::select(-rain_mm) 


```

## Clean breeding data 

```{r}
vultures.clean <- vultures |>
  clean_names() |>                               # ringing_date, laying_date
  rename_with(~ gsub("_", ".", .x)) |>           # ringing.date, laying.dater
  mutate(
    ringing.date = ringing.date |> as.character() |> str_trim(),
    ringing.date = if_else(ringing.date %in% c("", "NA", "?"),
                           NA_character_, ringing.date),
    ringing.date = ymd(gsub("/", "-", ringing.date)),
    
    laying.date  = laying.date |> as.character() |> str_trim(),
    laying.date  = if_else(laying.date %in% c("", "NA", "?"),
                           NA_character_, laying.date),
    laying.date  = ymd(gsub("/", "-", laying.date))
  )
```

## Explore Data 

```{r}
glimpse(vultures.clean)
summary(vultures.clean)
colSums(is.na(vultures.clean))

```

### Active Nests per year 

```{r}
active.nests.raw <- vultures.clean |>
mutate(year = year(ringing.date)) |>
group_by(year) |>
summarise(active_nests = n(), .groups = "drop")

ggplot(active.nests.raw, aes(x = year, y = active_nests)) +
geom_col(fill = "#89c5d6", alpha = 0.85) +
labs(x = "Year", y = "Number of active nests") +
theme_bw() +
theme(panel.grid = element_blank())

```

### Success proportion

```{r}
failed.nests.raw <- vultures.clean |>
mutate(year = year(ringing.date)) |>
group_by(year) |>
summarise(
active_nests  = n(),
success_nests = sum(!is.na(laying.date)),
success_prop  = success_nests / active_nests,
.groups       = "drop"
)

ggplot(failed.nests.raw, aes(x = success_prop)) +
geom_histogram(bins = 15, fill = "#89c5d6") +
labs(x = "Breeding success proportion", y = "Count") +
theme_bw() +
theme(panel.grid = element_blank())

```


### Annual Weather Summaries 

```{r}
weather_yearly <- WeatherData_clean |>
group_by(YEAR) |>
summarise(
mean_temp  = mean(TEMP, na.rm = TRUE),
max_temp   = max(MAX, na.rm = TRUE),
min_temp   = min(MIN, na.rm = TRUE),
total_rain = sum(PRCP, na.rm = TRUE),
max_rain   = max(PRCP, na.rm = TRUE),
rain_days  = sum(PRCP > 0, na.rm = TRUE),
mean_wind  = mean(WDSP, na.rm = TRUE),
max_wind   = max(MXSPD, na.rm = TRUE),
hail_days  = sum(I_HAIL, na.rm = TRUE),
.groups    = "drop"
)

# Check the corrected 2004 rainfall

weather_yearly[weather_yearly$YEAR == 2004,
c("YEAR", "total_rain", "max_rain", "rain_days")]

```

### Plot Annual Rainfall

```{r}
ggplot(weather_yearly, aes(x = YEAR, y = total_rain)) +
geom_line() +
geom_point() +
theme_bw() +
labs(x = "Year", y = "Total annual rainfall (mm)")

```

### Rain over time 

```{r}
library(grid) 

rain_yearly <- weather_yearly

rain_long <- rain_yearly |>
pivot_longer(
cols = c(total_rain, max_rain, rain_days),
names_to = "metric",
values_to = "value"
) |>
mutate(
metric = factor(
metric,
levels = c("total_rain", "max_rain", "rain_days")
),
metric_label = case_when(
metric == "total_rain" ~ "Total annual rainfall (mm)",
metric == "max_rain"   ~ "Max daily rainfall (mm)",
metric == "rain_days"  ~ "Number of rainy days (> 0 mm)"
),
metric_label = factor(
metric_label,
levels = c(
"Total annual rainfall (mm)",
"Max daily rainfall (mm)",
"Number of rainy days (> 0 mm)"
)
)
)

ggplot(rain_long, aes(x = YEAR, y = value)) +
geom_line(linewidth = 0.7) +
geom_point(size = 1.3) +
facet_wrap(~ metric_label, ncol = 1, scales = "free_y") +
theme_classic() +
labs(
x = "Year",
y = NULL
) +
theme(
strip.text    = element_text(size = 9, face = "bold"),
axis.title.x  = element_text(size = 10),
axis.text     = element_text(size = 8),
panel.spacing = unit(0.7, "lines")
)

```

### Check min temp 

```{r}
# Yearly 

ggplot(weather_yearly, aes(x = YEAR, y = min_temp)) +
geom_line() +
geom_point() +
theme_bw() +
labs(x = "Year", y = "Annual minimum temperature (°C)")

```

```{r}
# Daily 

weather_daily <- WeatherData_clean |>
group_by(YEAR, MONTH, DAY) |>
summarise(
mean_temp  = mean(TEMP, na.rm = TRUE),
max_temp   = max(MAX,  na.rm = TRUE),
min_temp   = min(MIN,  na.rm = TRUE),
total_rain = sum(PRCP, na.rm = TRUE),
max_rain   = max(PRCP, na.rm = TRUE),
rain_days  = sum(PRCP > 0, na.rm = TRUE),
mean_wind  = mean(WDSP, na.rm = TRUE),
max_wind   = max(MXSPD, na.rm = TRUE),
hail_days  = sum(I_HAIL, na.rm = TRUE),
.groups    = "drop"
)

temp_daily <- weather_daily |>
mutate(
min_temp = ifelse(is.infinite(min_temp), NA_real_, min_temp),
max_temp = ifelse(is.infinite(max_temp), NA_real_, max_temp)
)

summary(temp_daily$min_temp)
summary(temp_daily$max_temp)


```

### Yearly temp summaries 

```{r}
weather_yearly_temp <- weather_daily |>
filter(YEAR >= 1993, YEAR <= 2024) |>
group_by(YEAR) |>
summarise(
mean_temp = mean(mean_temp, na.rm = TRUE),
max_temp  = max(max_temp, na.rm = TRUE),
min_temp  = min(min_temp, na.rm = TRUE),
.groups   = "drop"
)

summary(weather_yearly_temp$min_temp)
summary(weather_yearly_temp$max_temp)

```

### Temps over time 

```{r}
min_temp <- ggplot(weather_yearly_temp, aes(YEAR, min_temp)) +
geom_line() +
geom_point() +
theme_bw() +
labs(x = "Year", y = "Annual minimum temperature (°C)")

max_temp <- ggplot(weather_yearly_temp, aes(x = YEAR, y = max_temp)) +
geom_line() +
geom_point() +
theme_bw() +
labs(
x = "Year",
y = "Annual maximum temperature (°C)",
title = "Annual Maximum Temperature (1993–2024)"
)

mean_temp <- ggplot(weather_yearly_temp, aes(x = YEAR, y = mean_temp)) +
geom_line() +
geom_point() +
theme_bw() +
labs(
x = "Year",
y = "Annual mean temperature (°C)",
title = "Annual Mean Temperature (1993–2024)"
)

```

```{r}
temp_yearly_long <- weather_yearly_temp |>
pivot_longer(
cols = c(max_temp, min_temp, mean_temp),
names_to = "type",
values_to = "value"
) |>
mutate(
type = factor(
type,
levels = c("max_temp", "min_temp", "mean_temp"),
labels = c("Annual Maximum Temperature (°C)",
"Annual Minimum Temperature (°C)",
"Annual Mean Temperature (°C)")
)
)

ggplot(temp_yearly_long, aes(x = YEAR, y = value)) +
geom_line(size = 0.7) +
geom_point(size = 1.5) +
facet_wrap(~ type, scales = "free_y", ncol = 1) +
theme_classic(base_size = 11) +
theme(
strip.text   = element_text(size = 10, face = "bold"),
axis.title   = element_text(size = 9),
axis.text    = element_text(size = 8),
panel.spacing = unit(0.8, "lines")
) +
labs(
x = "Year",
y = "",
title = "Annual Temperature Trends (1993–2024)"
)

```

### Lagged Weather summaries 

```{r}
weather_yearly_lag <- weather_yearly |>
arrange(YEAR) |>
mutate(
across(
c(mean_temp, max_temp, min_temp, total_rain, max_rain,
rain_days, mean_wind, max_wind, hail_days),
~ lag(.x, 1), .names = "lag_{.col}"
)
)

```

### Daily weather with lagged variables 
```{r}
weather_lag <- WeatherData_clean |>
mutate(
mean_temp = readr::parse_number(as.character(TEMP)),
max_temp  = readr::parse_number(as.character(MAX)),
min_temp  = readr::parse_number(as.character(MIN)),
mean_wind = readr::parse_number(as.character(WDSP)),
max_wind  = readr::parse_number(as.character(MXSPD)),
rain      = readr::parse_number(as.character(PRCP)),
rain_day  = as.integer(replace_na(rain, 0) > 0),
hail      = I_HAIL
) |>
arrange(date)
 
```

### Check for weather correlation 

```{r}
weather_yearly |>
  dplyr::select(
    mean_temp, max_temp, min_temp,
    total_rain, max_rain, rain_days,
    mean_wind, max_wind, hail_days
  )


```

```{r}
cor_mat <- weather_yearly |>
dplyr::select(mean_temp, max_temp, min_temp, total_rain, max_rain,
rain_days, mean_wind, max_wind, hail_days) |>
cor(use = "pairwise.complete.obs")

cor_df <- as.data.frame(cor_mat) |>
rownames_to_column("var1") |>
pivot_longer(-var1, names_to = "var2", values_to = "cor")

ggplot(cor_df, aes(x = var1, y = var2, fill = cor)) +
geom_tile() +
scale_fill_gradient2(
low = "#b2182b", mid = "white", high = "#2166ac",
midpoint = 0, limits = c(-1, 1)
) +
labs(x = "", y = "", fill = "Correlation") +
theme_bw() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
panel.grid  = element_blank()
)

```
 
### All weather across years

```{r}
weather_yearly |>
pivot_longer(-YEAR) |>
ggplot(aes(x = YEAR, y = value)) +
geom_line(colour = "#89c5d6") +
facet_wrap(~ name, scales = "free_y") +
labs(x = "Year", y = "Value") +
theme_bw() +
theme(panel.grid = element_blank())

```



## Objective 1

```{r}
# Effort Data 

active.nests <- vultures.clean |>
mutate(year = year(ringing.date)) |>
group_by(year) |>
summarise(active_nests = n(), .groups = "drop")

effort_weather <- active.nests |>
left_join(weather_yearly, by = c("year" = "YEAR"))

```


### Year only model 

```{r}
m_year <- glm.nb(active_nests ~ year, data = active.nests)
summary(m_year)
check_overdispersion(m_year)

```

### Autocorrelation in residuals

```{r}
res_effort <- residuals(m_year, type = "pearson")

acf(res_effort,
main = "ACF of residuals: breeding effort (active nests)")

```


### Rainfall 

```{r}
effort_weather <- effort_weather |>
mutate(
z_total_rain = scale(total_rain),
z_max_rain   = scale(max_rain),
z_rain_days  = scale(rain_days)
)

m_rain_only <- glm.nb(
active_nests ~ z_total_rain + z_max_rain + z_rain_days,
data = effort_weather
)
summary(m_rain_only)

```

### Temp 

```{r}
effort_weather <- effort_weather |>
mutate(
z_mean_temp = scale(mean_temp),
z_max_temp  = scale(max_temp),
z_min_temp  = scale(min_temp)
)

max_temp_mod <- glm.nb(
active_nests ~ z_max_temp,
data = effort_weather
)
summary(max_temp_mod)

min_temp_mod <- glm.nb(
active_nests ~ z_min_temp,
data = effort_weather
)
summary(min_temp_mod)

mean_temp_mod <- glm.nb(
active_nests ~ z_mean_temp,
data = effort_weather
)
summary(mean_temp_mod)

```


### Wind 

```{r}
effort_weather <- effort_weather |>
mutate(
z_mean_wind = scale(mean_wind),
z_max_wind  = scale(max_wind)
)

m_wind_only <- glm.nb(
active_nests ~ z_mean_wind + z_max_wind,
data = effort_weather
)
summary(m_wind_only)

```

### Hail 

```{r}
effort_weather <- effort_weather |>
mutate(z_hail_days = scale(hail_days))

m_hail_only <- glm.nb(
active_nests ~ z_hail_days,
data = effort_weather
)
summary(m_hail_only)

```



### Active nests across years 

```{r}
active.nests <- vultures.clean |>
mutate(year = year(ringing.date)) |>
group_by(year) |>
summarise(active_nests = n(), .groups = "drop")

m_year <- glm.nb(active_nests ~ year, data = active.nests)

active.nests_plot <- active.nests |>
mutate(pred_year = predict(m_year, newdata = active.nests, type = "response"))

ggplot(active.nests_plot, aes(x = year, y = active_nests)) +
geom_col(fill = "#89c5d6", alpha = 0.85) +
geom_line(aes(y = pred_year), linewidth = 1.1, colour = "black") +
labs(
x = "Year",
y = "Number of active nests"
) +
theme_bw() +
theme(panel.grid = element_blank())

```

### Effects of max temp on effort

```{r}
effort_weather <- active.nests |>
left_join(weather_yearly, by = c("year" = "YEAR")) |>
mutate(
z_total_rain = as.numeric(scale(total_rain)),
z_max_rain   = as.numeric(scale(max_rain)),
z_rain_days  = as.numeric(scale(rain_days)),
z_mean_temp  = as.numeric(scale(mean_temp)),
z_max_temp   = as.numeric(scale(max_temp)),
z_min_temp   = as.numeric(scale(min_temp)),
z_mean_wind  = as.numeric(scale(mean_wind)),
z_max_wind   = as.numeric(scale(max_wind)),
z_hail_days  = as.numeric(scale(hail_days))
)

m_eff_maxtemp <- glm.nb(
active_nests ~ z_max_temp,
data = effort_weather
)
summary(m_eff_maxtemp)

new_eff_temp <- tibble(
z_max_temp = seq(
min(effort_weather$z_max_temp, na.rm = TRUE),
max(effort_weather$z_max_temp, na.rm = TRUE),
length.out = 100
)
) |>
mutate(
pred_nests = predict(
m_eff_maxtemp,
newdata = cur_data(),
type = "response"
)
)

ggplot(effort_weather, aes(x = z_max_temp, y = active_nests)) +
geom_point(alpha = 0.7) +
geom_line(
data = new_eff_temp,
aes(x = z_max_temp, y = pred_nests),
linewidth = 1.1
) +
labs(
x = "Annual maximum temperature (scaled)",
y = "Number of active nests"
) +
theme_bw() +
theme(panel.grid = element_blank())

```



```{r}
acf(active.nests$active_nests)

```

## Objective 2
### Success DF 

```{r}
failed.nests <- vultures.clean |>
mutate(year = year(ringing.date)) |>
filter(!is.na(year)) |>
group_by(year) |>
summarise(
active_nests  = n(),
success_nests = sum(!is.na(laying.date)),
failed_nests  = active_nests - success_nests,
success_prop  = success_nests / active_nests,
.groups       = "drop"
) |>
filter(active_nests > 0)

```

### Year only model 

```{r}
success_year <- glm(
cbind(success_nests, failed_nests) ~ year,
family = binomial,
data   = failed.nests
)
summary(success_year)
check_overdispersion(success_year)

```

### Rain 

```{r}
success_df <- failed.nests |>
left_join(weather_yearly, by = c("year" = "YEAR")) |>
mutate(
z_total_rain = as.numeric(scale(total_rain)),
z_max_rain   = as.numeric(scale(max_rain)),
z_rain_days  = as.numeric(scale(rain_days))
)

success_rain <- glm(
cbind(success_nests, failed_nests) ~
z_total_rain + z_max_rain + z_rain_days,
family = binomial,
data   = success_df
)
summary(success_rain)
check_overdispersion(success_rain)

```

### Temp 

```{r}
success_df <- success_df |>
mutate(
z_mean_temp = as.numeric(scale(mean_temp)),
z_max_temp  = as.numeric(scale(max_temp)),
z_min_temp  = as.numeric(scale(min_temp))
)

success_minT <- glm(
cbind(success_nests, failed_nests) ~ z_min_temp,
family = binomial,
data   = success_df
)
summary(success_minT)
check_overdispersion(success_minT)

success_maxT <- glm(
cbind(success_nests, failed_nests) ~ z_max_temp,
family = binomial,
data   = success_df
)
summary(success_maxT)
check_overdispersion(success_maxT)

success_meanT <- glm(
cbind(success_nests, failed_nests) ~ z_mean_temp,
family = binomial,
data   = success_df
)
summary(success_meanT)
check_overdispersion(success_meanT)

```

### WInd 

```{r}
success_df <- success_df |>
mutate(
z_mean_wind = as.numeric(scale(mean_wind)),
z_max_wind  = as.numeric(scale(max_wind))
)

m_success_wind <- glm(
cbind(success_nests, failed_nests) ~ z_mean_wind + z_max_wind,
family = binomial,
data   = success_df
)
summary(m_success_wind)
check_overdispersion(m_success_wind)

```

### Hail 

```{r}
success_df <- success_df |>
mutate(
z_hail_days = as.numeric(scale(hail_days))
)

m_success_hail <- glm(
cbind(success_nests, failed_nests) ~ z_hail_days,
family = binomial,
data   = success_df
)
summary(m_success_hail)
check_overdispersion(m_success_hail)

```

## Objective 3

### 60 and 30 day pre laying period 

```{r}
timing_df <- vultures.clean |>
filter(!is.na(laying.date)) |>
mutate(
year    = year(laying.date),
lay_DOY = yday(laying.date)
)

summarise_60 <- function(lay_date, weather) {
w <- weather |>
filter(date > (lay_date - days(60)), date <= lay_date)

tibble(
mean_temp_60  = mean(w$mean_temp, na.rm = TRUE),
max_temp_60   = mean(w$max_temp, na.rm = TRUE),
min_temp_60   = mean(w$min_temp, na.rm = TRUE),
total_rain_60 = sum(w$rain, na.rm = TRUE),
rain_days_60  = sum(w$rain_day, na.rm = TRUE),
mean_wind_60  = mean(w$mean_wind, na.rm = TRUE),
max_wind_60   = mean(w$max_wind, na.rm = TRUE),
hail_days_60  = sum(w$hail, na.rm = TRUE)
)
}

timing_weather_60 <- timing_df |>
mutate(win60 = purrr::map(laying.date, summarise_60, weather = weather_lag)) |>
unnest(win60)

summarise_30 <- function(lay_date, weather) {
  w <- weather |>
    filter(date > (lay_date - days(30)), date <= lay_date)

  tibble(
    mean_temp_30  = mean(w$mean_temp, na.rm = TRUE),
    max_temp_30   = mean(w$max_temp,  na.rm = TRUE),
    min_temp_30   = mean(w$min_temp,  na.rm = TRUE),
    total_rain_30 = sum(w$rain,       na.rm = TRUE),
    rain_days_30  = sum(w$rain_day,   na.rm = TRUE),
    mean_wind_30  = mean(w$mean_wind, na.rm = TRUE),
    max_wind_30   = mean(w$max_wind,  na.rm = TRUE),
    hail_days_30  = sum(w$hail,       na.rm = TRUE)
  )
}

timing_weather_30 <- timing_df |>
  mutate(win30 = purrr::map(laying.date, summarise_30, weather = weather_lag)) |>
  tidyr::unnest(win30)

```

### Temp 

```{r}
m_timing_temp_60 <- lm(
lay_DOY ~ mean_temp_60 + max_temp_60 + min_temp_60,
data = timing_weather_60
)
summary(m_timing_temp_60)

```


### Rain 

```{r}
m_timing_rain_60 <- lm(
lay_DOY ~ total_rain_60 + rain_days_60,
data = timing_weather_60
)
summary(m_timing_rain_60)

```

### Hail 

```{r}
m_timing_rain_60 <- lm(
lay_DOY ~ total_rain_60 + rain_days_60,
data = timing_weather_60
)
summary(m_timing_rain_60)

```

### Test 

```{r}
plot(failed.nests$year, failed.nests$success_prop)

```









--------------------------------------------------------------------------------

## Candidate model set

### Objective 1

```{r}

objective1_table <- tribble(
  ~`Hypothesis / justification`, ~Model,

  # ---- Temperature ----
  "**Temp**", NA,
  "Warmer years increase energetic cost of adult birds, reducing likelihood to breed.",
  "active_nests ~ mean_temp",

  "Extreme heat events cause thermal stress, reducing breeding effort (active cooling is energetically costly and may reduce adult condition).",
  "active_nests ~ max_temp",

  "Cold extremes increase thermoregulatory demand (often increasing time spent foraging), reducing effort put into breeding",
  "active_nests ~ min_temp",

  # ---- Rain ----
  "**Rain**", NA,
  "High rainfall reduces foraging efficiency and adult condition, reducing breeding effort.",
  "active_nests ~ total_rain",

  "Prolonged rainfall conditions reduce breeding effort by limiting foraging opportunity (fewer or weaker thermals for soaring)",
  "active_nests ~ rain_days",

  "Intense rainfall events decrease foraging efficiency and nest attendance, reducing breeding effort.",
  "active_nests ~ max_rain",

  "Previous year’s rainfall influences food availability and adult condition, affecting breeding effort in the following year.",
  "active_nests ~ lag_total_rain",

  # ---- Wind ----
  "**Wind**", NA,
  "Persistent windy conditions increase the cost of flying, limiting foraging and the energy available for reproduction, reducing breeding effort",
  "active_nests ~ mean_wind",

  "Extreme winds increase nest damage risk, reducing the likelihood that adults will attempt breeding (WBV often reuse nests from previous years) ",
  "active_nests ~ max_wind",

  # ---- Hail ----
  "**Hail**", NA,
  "Severe storm events increase disturbance and nest damage risk, reducing breeding effort",
  "active_nests ~ hail_days",

  # ---- Joint Effects ----
  "**Joint effects**", NA,
  "Cold stress combined with prolonged wet conditions jointly limit breeding effort",
  "active_nests ~ min_temp + total_rain",

  "Cold stress combined with intense rainfall events reduces breeding effort",
  "active_nests ~ min_temp + max_rain",

  "Cold extremes combined with extreme wind increase energetic costs and breeding risk, reducing breeding effort",
  "active_nests ~ min_temp + max_wind",

  "Severe storm exposure combined with extreme wind increases nest disturbance, reducing breeding effort",
  "active_nests ~ hail_days + max_wind",

  "Reduced thermals for soaring combined with high flight costs limit breeding effort",
  "active_nests ~ max_rain + max_wind",
  
  "Heat stress combined with prolonged wet conditions jointly reduce breeding effort by increasing energetic costs while limiting foraging",
  "active_nests ~ max_temp + rain_days",
  
 " High annual rainfall and frequent hail events each impose energetic and disturbance costs that reduce breeding effort.",
"active_nests ~ hail_days + rain_days",

  # ---- Interactive Effects ----
  "**Interactive effects**", NA,
  "The negative effect of cold extremes on breeding effort is increased in persistently wet years.",
  "active_nests ~ min_temp * rain_days",

  "Cold-related energetic stress is amplified in windy years due to increased heat loss and flight costs",
  "active_nests ~ min_temp * mean_wind",

  "Adult condition resulting from the previous year interacts with current-year heat stress to influence breeding effort",
  "active_nests ~ lag_total_rain * max_temp"
)

objective1_table_clean <- objective1_table |>
  dplyr::mutate(Model = ifelse(is.na(Model), "", Model))

kable(
  objective1_table_clean,
  align = c("l", "l"),
  caption = "Objective 1 candidate model set for breeding effort (active nests)"
)




```

```{r}
# Annual effort: number of active nests per year
active.nests <- vultures.clean |>
  mutate(year = year(ringing.date)) |>
  group_by(year) |>
  summarise(active_nests = n(), .groups = "drop")


# Join to weather, create log effort response
effort_weather <- active.nests |>
  left_join(weather_yearly_lag, by = c("year" = "YEAR")) |>
  filter(!is.na(lag_total_rain)) |>
  mutate(
    log_active_nests = log(active_nests)
  )

```


```{r}
# checking residuals
par(mfrow = c(1, 2))
```


### Fitingt then no-year models

```{r}
# Baseline 
m_null <- lm(log_active_nests ~ 1, data = effort_weather)

# Single predictor models 
m_mean_temp      <- lm(log_active_nests ~ mean_temp,      data = effort_weather)
m_max_temp       <- lm(log_active_nests ~ max_temp,       data = effort_weather)
m_min_temp       <- lm(log_active_nests ~ min_temp,       data = effort_weather)

m_total_rain     <- lm(log_active_nests ~ total_rain,     data = effort_weather)
m_rain_days      <- lm(log_active_nests ~ rain_days,      data = effort_weather)
m_max_rain       <- lm(log_active_nests ~ max_rain,       data = effort_weather)
m_lag_total_rain <- lm(log_active_nests ~ lag_total_rain, data = effort_weather)

m_mean_wind      <- lm(log_active_nests ~ mean_wind,      data = effort_weather)
m_max_wind       <- lm(log_active_nests ~ max_wind,       data = effort_weather)
m_hail_days      <- lm(log_active_nests ~ hail_days,      data = effort_weather)

# Joint effects 
m_minT_totalR    <- lm(log_active_nests ~ min_temp + total_rain,  data = effort_weather)
m_minT_maxR      <- lm(log_active_nests ~ min_temp + max_rain,    data = effort_weather)
m_minT_maxW      <- lm(log_active_nests ~ min_temp + max_wind,    data = effort_weather)
m_hail_maxW      <- lm(log_active_nests ~ hail_days + max_wind,   data = effort_weather)
m_maxR_maxW      <- lm(log_active_nests ~ max_rain + max_wind,    data = effort_weather)
m_maxT_rainDays  <- lm(log_active_nests ~ max_temp + rain_days,   data = effort_weather)
m_hail_rainDays  <- lm(log_active_nests ~ hail_days + rain_days,  data = effort_weather)

# Interactions 
m_minT_x_rainDays <- lm(log_active_nests ~ min_temp * rain_days,      data = effort_weather)
m_minT_x_meanWind <- lm(log_active_nests ~ min_temp * mean_wind,      data = effort_weather)
m_lagR_x_maxT     <- lm(log_active_nests ~ lag_total_rain * max_temp, data = effort_weather)
```

### Fit with year models 

```{r}
# Baseline 
m_year <- lm(log_active_nests ~ year, data = effort_weather)

# Single predictor models 
m_mean_temp_year      <- lm(log_active_nests ~ year + mean_temp,      data = effort_weather)
m_max_temp_year       <- lm(log_active_nests ~ year + max_temp,       data = effort_weather)
m_min_temp_year       <- lm(log_active_nests ~ year + min_temp,       data = effort_weather)

m_total_rain_year     <- lm(log_active_nests ~ year + total_rain,     data = effort_weather)
m_rain_days_year      <- lm(log_active_nests ~ year + rain_days,      data = effort_weather)
m_max_rain_year       <- lm(log_active_nests ~ year + max_rain,       data = effort_weather)
m_lag_total_rain_year <- lm(log_active_nests ~ year + lag_total_rain, data = effort_weather)

m_mean_wind_year      <- lm(log_active_nests ~ year + mean_wind,      data = effort_weather)
m_max_wind_year       <- lm(log_active_nests ~ year + max_wind,       data = effort_weather)
m_hail_days_year      <- lm(log_active_nests ~ year + hail_days,      data = effort_weather)

# Joint effects 
m_minT_totalR_year    <- lm(log_active_nests ~ year + min_temp + total_rain, data = effort_weather)
m_minT_maxR_year      <- lm(log_active_nests ~ year + min_temp + max_rain,   data = effort_weather)
m_minT_maxW_year      <- lm(log_active_nests ~ year + min_temp + max_wind,   data = effort_weather)
m_hail_maxW_year      <- lm(log_active_nests ~ year + hail_days + max_wind,  data = effort_weather)
m_maxR_maxW_year      <- lm(log_active_nests ~ year + max_rain + max_wind,   data = effort_weather)
m_maxT_rainDays_year  <- lm(log_active_nests ~ year + max_temp + rain_days,  data = effort_weather)
m_hail_rainDays_year  <- lm(log_active_nests ~ year + hail_days + rain_days, data = effort_weather)

# Interactions 
m_minT_x_rainDays_year <- lm(log_active_nests ~ year + min_temp * rain_days,      data = effort_weather)
m_minT_x_meanWind_year <- lm(log_active_nests ~ year + min_temp * mean_wind,      data = effort_weather)
m_lagR_x_maxT_year     <- lm(log_active_nests ~ year + lag_total_rain * max_temp, data = effort_weather)
```



---

Two separate AICc model selection runs

```{r}
# AIC 1: without year
cand_effort_no_year <- list(
  null            = m_null,

  mean_temp       = m_mean_temp,
  max_temp        = m_max_temp,
  min_temp        = m_min_temp,
  total_rain      = m_total_rain,
  rain_days       = m_rain_days,
  max_rain        = m_max_rain,
  lag_total_rain  = m_lag_total_rain,
  mean_wind       = m_mean_wind,
  max_wind        = m_max_wind,
  hail_days       = m_hail_days,

  minT_totalR     = m_minT_totalR,
  minT_maxR       = m_minT_maxR,
  minT_maxW       = m_minT_maxW,
  hail_maxW       = m_hail_maxW,
  maxR_maxW       = m_maxR_maxW,
  maxT_rainDays   = m_maxT_rainDays,
  hail_rainDays   = m_hail_rainDays,

  minT_x_rainDays = m_minT_x_rainDays,
  minT_x_meanWind = m_minT_x_meanWind,
  lagR_x_maxT     = m_lagR_x_maxT
)

aic_effort_no_year <- aictab(cand.set = cand_effort_no_year, modnames = names(cand_effort_no_year))
aic_effort_no_year
```

```{r}
# AIC 2: with year
cand_effort_with_year <- list(
  year               = m_year,

  mean_temp          = m_mean_temp_year,
  max_temp           = m_max_temp_year,
  min_temp           = m_min_temp_year,
  total_rain         = m_total_rain_year,
  rain_days          = m_rain_days_year,
  max_rain           = m_max_rain_year,
  lag_total_rain     = m_lag_total_rain_year,
  mean_wind          = m_mean_wind_year,
  max_wind           = m_max_wind_year,
  hail_days          = m_hail_days_year,

  minT_totalR        = m_minT_totalR_year,
  minT_maxR          = m_minT_maxR_year,
  minT_maxW          = m_minT_maxW_year,
  hail_maxW          = m_hail_maxW_year,
  maxR_maxW          = m_maxR_maxW_year,
  maxT_rainDays      = m_maxT_rainDays_year,
  hail_rainDays      = m_hail_rainDays_year,

  minT_x_rainDays    = m_minT_x_rainDays_year,
  minT_x_meanWind    = m_minT_x_meanWind_year,
  lagR_x_maxT        = m_lagR_x_maxT_year
)

aic_effort_with_year <- aictab(cand.set = cand_effort_with_year, modnames = names(cand_effort_with_year))
aic_effort_with_year

```

### Check residuals

```{r}
# identify top-ranked model (no year)
best_no_year_name <- aic_effort_no_year$Modnames[1]
best_no_year_E <- cand_effort_no_year[[best_no_year_name]]

par(mfrow = c(2,2))
plot(best_no_year_E)

# identify top-ranked model (with year)
best_with_year_name <- aic_effort_with_year$Modnames[1]
best_with_year_E <- cand_effort_with_year[[best_with_year_name]]

par(mfrow = c(2,2))
plot(best_with_year_E)

```

```{r}
# year-only baseline and best with-year model
summary(m_year)$adj.r.squared
summary(best_with_year_E)$adj.r.squared

# best no-year model
summary(best_no_year_E)$adj.r.squared
```

### Figures 

```{r}

ggplot(effort_weather, aes(x = year, y = active_nests)) +
  geom_point(size = 2, colour = "grey") +
  geom_smooth(method = "lm", se = TRUE, colour = "grey30") +
  scale_x_continuous(breaks = seq(min(effort_weather$year), max(effort_weather$year), by = 5)) +
  labs(
    x = "Year",
    y = "Number of active nests",
    title = "Annual breeding effort at Dronfield Nature Reserve"
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())

```




```{r}

prep_aic_plot <- function(aic_obj, set_label){
  df <- as.data.frame(aic_obj)

  # model names
  if ("Modnames" %in% names(df)) df$model <- df$Modnames
  if (!"model" %in% names(df)) df$model <- rownames(df)

  df |>
    dplyr::mutate(set = set_label) |>
    dplyr::rename(delta = Delta_AICc, weight = AICcWt) |>
    dplyr::select(set, model, delta, weight)
}

aic_plot_df <- dplyr::bind_rows(
  prep_aic_plot(aic_effort_with_year, "With year"),
  prep_aic_plot(aic_effort_no_year, "Without year")
) |>
  dplyr::filter(delta <= 3) |>
  dplyr::group_by(set) |>
  dplyr::mutate(model = forcats::fct_reorder(model, -delta)) |>
  dplyr::ungroup()

ggplot(aic_plot_df, aes(x = delta, y = model)) +
  geom_vline(xintercept = 2, linetype = 2) +
  geom_point(aes(size = weight), colour = "grey20") +
  facet_wrap(~set, scales = "free_y") +
  scale_size_continuous(range = c(2, 8)) +
  labs(
    x = expression(Delta*"AICc (lower is better)"),
    y = NULL,
    title = "Support for candidate models with and without year",
    subtitle = "Only models with ΔAICc ≤ 3 are shown; point size indicates AICc weight"
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())
 
```

```{r}
library(dplyr)
library(ggplot2)
library(forcats)

plot_aic_facets_from_cands <- function(cand_with, cand_without,
                                       label_with = "With year",
                                       label_without = "Without year",
                                       daic_max = 3){

  build_df <- function(cand_list, panel_label){
    tibble(
      model_id = names(cand_list),
      AICc = sapply(cand_list, AICcmodavg::AICc)
    ) |>
      arrange(AICc) |>
      mutate(
        dAICc = AICc - min(AICc),
        weight = exp(-0.5 * dAICc) / sum(exp(-0.5 * dAICc)),
        panel = panel_label
      )
  }

  dat <- bind_rows(
    build_df(cand_with,    label_with),
    build_df(cand_without, label_without)
  ) |>
    filter(is.finite(dAICc), dAICc <= daic_max) |>
    group_by(panel) |>
    arrange(dAICc, .by_group = TRUE) |>
    mutate(model_id = fct_reorder(model_id, dAICc, .desc = TRUE)) |>
    ungroup()

  ggplot(dat, aes(x = dAICc, y = model_id, size = weight)) +
    geom_vline(xintercept = 2, linetype = "dashed") +
    geom_point(alpha = 0.9) +
    facet_wrap(~panel, scales = "free_y") +
    labs(
      x = expression(Delta*AIC[c]*" (lower is better)"),
      y = NULL,
      size = "AICc weight",
      title = "Support for candidate models with and without year",
      subtitle = paste0("Only models with ΔAICc ≤ ", daic_max,
                        " are shown; dashed line = ΔAICc = 2")
    ) +
    theme_bw() +
    theme(
      panel.grid = element_blank(),
      legend.position = "right"
    )
}

```

```{r}

# Table 1(weather-only) 
aic_df <- as.data.frame(aic_effort_no_year)

# model ids
if ("Modnames" %in% names(aic_df)) {
  aic_df <- aic_df |> dplyr::mutate(model_id = Modnames)
} else {
  aic_df <- tibble::rownames_to_column(aic_df, "model_id")
}

table1 <- aic_df |>
  dplyr::rename(
    K = K,
    AICc = AICc,
    `ΔAICc` = Delta_AICc,
    w = AICcWt
  ) |>
  dplyr::select(model_id, K, AICc, `ΔAICc`, w) |>
  dplyr::arrange(`ΔAICc`) 

# add Adj R2 + slope(SE)
get_stats <- function(mod){
  adjr2 <- summary(mod)$adj.r.squared
  if (length(coef(mod)) == 2) {
    cf <- summary(mod)$coefficients
    slope_se <- paste0(round(cf[2,1], 3), " (", round(cf[2,2], 3), ")")
  } else {
    slope_se <- ""
  }
  tibble::tibble(`Adj. R²` = adjr2, `slope (SE)` = slope_se)
}

stats_df <- lapply(table1$model_id, function(mn) get_stats(cand_effort_no_year[[mn]])) |>
  dplyr::bind_rows() |>
  dplyr::mutate(model_id = table1$model_id)

table1 <- table1 |>
  dplyr::left_join(stats_df, by = "model_id") |>
  dplyr::mutate(
    AICc = round(AICc, 2),
    `ΔAICc` = round(`ΔAICc`, 2),
    w = round(w, 3),
    `Adj. R²` = round(`Adj. R²`, 3)
  )

# grouping adn neat names 
group_order <- c("Baseline","Rain","Temperature","Wind","Hail","Joint effects","Interactions")

model_group <- function(m){
  dplyr::case_when(
    m == "null" ~ "Baseline",
    m %in% c("total_rain","rain_days","max_rain","lag_total_rain") ~ "Rain",
    m %in% c("mean_temp","max_temp","min_temp") ~ "Temperature",
    m %in% c("mean_wind","max_wind") ~ "Wind",
    m %in% c("hail_days") ~ "Hail",
    m %in% c("minT_totalR","minT_maxR","minT_maxW","hail_maxW","maxR_maxW","maxT_rainDays","hail_rainDays") ~ "Joint effects",
    m %in% c("minT_x_rainDays","minT_x_meanWind","lagR_x_maxT") ~ "Interactions",
    TRUE ~ "Joint effects"
  )
}

pretty_model <- function(x){
  dplyr::recode(
    x,
    "null"           = "Intercept only",
    "total_rain"     = "Total rainfall",
    "rain_days"      = "Rainy days",
    "max_rain"       = "Maximum daily rainfall",
    "lag_total_rain" = "Previous year's total rainfall",
    "mean_temp"      = "Mean temperature",
    "max_temp"       = "Maximum temperature",
    "min_temp"       = "Minimum temperature",
    "mean_wind"      = "Mean wind speed",
    "max_wind"       = "Maximum wind speed",
    "hail_days"      = "Hail days",
    "minT_totalR"     = "Min temperature + total rainfall",
    "minT_maxR"       = "Min temperature + max daily rainfall",
    "minT_maxW"       = "Min temperature + max wind speed",
    "hail_maxW"       = "Hail days + max wind speed",
    "maxR_maxW"       = "Max daily rainfall + max wind speed",
    "maxT_rainDays"   = "Max temperature + rainy days",
    "hail_rainDays"   = "Hail days + rainy days",
    "minT_x_rainDays" = "Min temperature × rainy days",
    "minT_x_meanWind" = "Min temperature × mean wind speed",
    "lagR_x_maxT"     = "Prev. rainfall × max temperature",
    .default = x
  )
}

table1_clean <- table1 |>
  dplyr::mutate(
    Group = model_group(model_id),
    Model = pretty_model(model_id),
    Group = factor(Group, levels = group_order)
  ) |>
  dplyr::arrange(Group, `ΔAICc`) |>
  dplyr::select(Group, Model, K, AICc, `ΔAICc`, w, `Adj. R²`, `slope (SE)`)

#print 
group_sizes <- table1_clean |>
  dplyr::count(Group, name = "n") |>
  dplyr::mutate(
    start = cumsum(dplyr::lag(n, default = 0)) + 1,
    end   = cumsum(n)
  )

tbl <- knitr::kable(
  table1_clean |> dplyr::select(-Group),
  caption = "Table 1. Weather-only candidate models explaining annual breeding effort (log number of active nests) at Dronfield. K = number of parameters; AICc = small-sample AIC; ΔAICc = difference from the best model; w = Akaike weight. Adjusted R² is shown for all models; slope (SE) is reported only for single-predictor models.",
  align = "l"
) |>
  kableExtra::kable_styling(full_width = FALSE)

for(i in seq_len(nrow(group_sizes))){
  tbl <- tbl |>
    kableExtra::pack_rows(as.character(group_sizes$Group[i]),
                          group_sizes$start[i],
                          group_sizes$end[i])
}

tbl


```

```{r}
ggplot(a_all, aes(x = Panel, y = `ΔAICc`)) +
  geom_jitter(width = 0.15, alpha = 0.6, size = 2) +
  geom_hline(yintercept = 2, linetype = "dashed") +
  labs(
    x = NULL,
    y = expression(Delta*AIC[c]),
    title = "Model support with and without year",
    subtitle = "Each point represents a fitted model; dashed line indicates weak support"
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())


```

```{r}
library(dplyr)
library(ggplot2)
library(tidytext)

aic_no_year_plot <- table1_clean |>
  filter(Group != "Baseline" | Model == "Intercept only") |>
  mutate(
    Model_f = reorder_within(Model, `ΔAICc`, Group),
    is_null = Model == "Intercept only"
  )

ggplot(aic_no_year_plot, aes(x = `ΔAICc`, y = Model_f)) +
  geom_vline(xintercept = 2, linetype = "dashed", colour = "grey40") +
  geom_point(aes(size = w, shape = is_null), alpha = 0.85) +
  scale_shape_manual(values = c(`FALSE` = 16, `TRUE` = 17), guide = "none") +
  scale_y_reordered() +
  scale_size_continuous(range = c(2.5, 7)) +
  labs(
    x = expression(Delta*AIC[c]),
    y = NULL,
    size = "Akaike weight",
    title = "Weather-only model support (year excluded)"
  ) +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    axis.text.y = element_text(size = 10)
  )

```

```{r}
library(dplyr)
library(ggplot2)
library(tidytext)

# build clean table from the WITH-YEAR AIC object
aic_with_year_plot <- as.data.frame(aic_effort_with_year) |>
  tibble::rownames_to_column("model_id") |>
  dplyr::rename(
    `ΔAICc` = Delta_AICc,
    w = AICcWt
  ) |>
  dplyr::mutate(
    Model = pretty_model(model_id),
    Model_f = reorder(Model, `ΔAICc`),
    is_null = model_id == "null"
  )

ggplot(aic_with_year_plot, aes(x = `ΔAICc`, y = Model_f)) +
  geom_vline(xintercept = 2, linetype = "dashed", colour = "grey40") +
  geom_point(aes(size = w, shape = is_null), alpha = 0.85) +
  scale_shape_manual(values = c(`FALSE` = 16, `TRUE` = 17), guide = "none") +
  scale_size_continuous(range = c(2.5, 7)) +
  labs(
    x = expression(Delta*AIC[c]),
    y = NULL,
    size = "Akaike weight",
    title = "Weather + year model support"
  ) +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    axis.text.y = element_text(size = 10)
  )

```



```{r}
digits_aic   <- 2
digits_r2    <- 3
digits_slope <- 3

group_order <- c("Baseline", "Rain", "Temperature", "Wind", "Hail", "Joint effects", "Interactions")

model_group_with_year <- function(m){
  dplyr::case_when(
    m %in% c("year") ~ "Baseline",
    m %in% c("total_rain","rain_days","max_rain","lag_total_rain") ~ "Rain",
    m %in% c("mean_temp","max_temp","min_temp") ~ "Temperature",
    m %in% c("mean_wind","max_wind") ~ "Wind",
    m %in% c("hail_days") ~ "Hail",
    m %in% c("minT_totalR","minT_maxR","minT_maxW","hail_maxW","maxR_maxW","maxT_rainDays","hail_rainDays") ~ "Joint effects",
    m %in% c("minT_x_rainDays","minT_x_meanWind","lagR_x_maxT") ~ "Interactions",
    TRUE ~ "Joint effects"
  )
}

pretty_model_with_year <- function(x){
  dplyr::recode(
    x,
    "year"           = "Year (baseline)",
    "total_rain"     = "Total rainfall",
    "rain_days"      = "Rainy days",
    "max_rain"       = "Maximum daily rainfall",
    "lag_total_rain" = "Previous year's total rainfall",
    "mean_temp"      = "Mean temperature",
    "max_temp"       = "Maximum temperature",
    "min_temp"       = "Minimum temperature",
    "mean_wind"      = "Mean wind speed",
    "max_wind"       = "Maximum wind speed",
    "hail_days"      = "Hail days",
    "minT_totalR"     = "Min temperature + total rainfall",
    "minT_maxR"       = "Min temperature + max daily rainfall",
    "minT_maxW"       = "Min temperature + max wind speed",
    "hail_maxW"       = "Hail days + max wind speed",
    "maxR_maxW"       = "Max daily rainfall + max wind speed",
    "maxT_rainDays"   = "Max temperature + rainy days",
    "hail_rainDays"   = "Hail days + rainy days",
    "minT_x_rainDays" = "Min temperature × rainy days",
    "minT_x_meanWind" = "Min temperature × mean wind speed",
    "lagR_x_maxT"     = "Prev. rainfall × max temperature",
    .default = x
  )
}

aic_df2 <- as.data.frame(aic_effort_with_year)

if ("Modnames" %in% names(aic_df2)) {
  aic_df2 <- aic_df2 |> dplyr::mutate(model = Modnames)
} else {
  aic_df2 <- tibble::rownames_to_column(aic_df2, "model")
}

aic_df2 <- aic_df2 |>
  dplyr::rename(
    K     = K,
    AICc  = AICc,
    dAICc = Delta_AICc,
    w     = AICcWt
  ) |>
  dplyr::select(model, K, AICc, dAICc, w) |>
  dplyr::arrange(dAICc)

get_stats_with_year <- function(mod){
  adjr2 <- summary(mod)$adj.r.squared

  if (length(coef(mod)) == 3) {   # intercept + year + ONE weather predictor
    cf <- summary(mod)$coefficients
    slope <- unname(cf[3, 1])
    se    <- unname(cf[3, 2])
    slope_se <- paste0(
      round(slope, digits_slope),
      " (", round(se, digits_slope), ")"
    )
  } else {
    slope_se <- ""
  }

  tibble::tibble(adj_R2 = adjr2, slope_SE = slope_se)
}


stats_df2 <- lapply(aic_df2$model, function(mn) get_stats_with_year(cand_effort_with_year[[mn]])) |>
  dplyr::bind_rows() |>
  dplyr::mutate(model = aic_df2$model)

table2 <- aic_df2 |>
  dplyr::left_join(stats_df2, by = "model") |>
  dplyr::mutate(
    AICc   = round(AICc, digits_aic),
    dAICc  = round(dAICc, digits_aic),
    w      = round(w, 3),
    adj_R2 = round(adj_R2, digits_r2)
  ) |>
  dplyr::mutate(
    model_id = model,
    Group = model_group_with_year(model_id),
    Model = pretty_model_with_year(model_id),
    Group = factor(Group, levels = group_order)
  ) |>
  dplyr::arrange(Group, dAICc) |>
  dplyr::rename(
    `ΔAICc` = dAICc,
    `Adj. R²` = adj_R2,
    `slope (SE)` = slope_SE
  ) |>
  dplyr::select(Group, Model, K, AICc, `ΔAICc`, w, `Adj. R²`, `slope (SE)`)

group_sizes2 <- table2 |>
  dplyr::count(Group, name = "n") |>
  dplyr::filter(n > 0) |>
  dplyr::mutate(
    start = cumsum(dplyr::lag(n, default = 0)) + 1,
    end   = cumsum(n)
  )

tbl2 <- knitr::kable(
  table2 |> dplyr::select(-Group),
  caption = "Table 2. Candidate models including year explaining annual breeding effort (log number of active nests) at Dronfield. K = number of parameters; AICc = small-sample AIC; ΔAICc = difference from the best model; w = Akaike weight. Adjusted R² is shown for all models; slope (SE) is reported for each model (non-intercept terms shown as estimate (SE)).",
  align = "l"
) |>
  kableExtra::kable_styling(full_width = FALSE)

for(i in seq_len(nrow(group_sizes2))){
  tbl2 <- tbl2 |>
    kableExtra::pack_rows(
      as.character(group_sizes2$Group[i]),
      group_sizes2$start[i],
      group_sizes2$end[i]
    )
}

tbl2



```


```{r}
library(dplyr)
library(ggplot2)
library(forcats)
library(tidytext)   

daic_keep <- 4

effort_bar_df2 <- bind_rows(
  prep_aictab_bar(aic_effort_with_year, "With year"),
  prep_aictab_bar(aic_effort_no_year,   "Without year")
) |>
  group_by(panel) |>
  filter(dAICc <= daic_keep) |>
  mutate(
    # reorder *within* each facet so best (0) ends up at the bottom after coord_flip()
    label_w = tidytext::reorder_within(label, dAICc, panel)

  ) |>
  ungroup()

ggplot(effort_bar_df2, aes(x = label_w, y = dAICc, fill = is_best)) +
  geom_col(width = 0.7) +
  coord_flip() +
  geom_hline(yintercept = 2, linetype = "dashed") +
  facet_wrap(~panel, scales = "free_y") +
  tidytext::scale_x_reordered() +
  scale_fill_manual(values = c(`TRUE` = "steelblue", `FALSE` = "grey75"), guide = "none") +
  scale_y_continuous(limits = c(0, daic_keep), breaks = 0:daic_keep) +
  labs(
    x = NULL,
    y = expression(Delta*AIC[c]),
    title = 
"Objective 1: Model support for breeding effort",
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())

```
   subtitle = paste0(
"Only models with ΔAICc ≤ ", daic_keep,
                      " shown; dashed line = ΔAICc = 2")


--------------------------------------------------------------------------------


### Objective 2: Breeding success

```{r}
objective2_table <- tribble(
  ~`Hypothesis / justification`, ~Model,

  # ---- Temperature ----
  "**Temp**", "",
  "Extreme heat events cause chick heat stress and dehydration, reducing fledging success",
  "success ~ max_temp + (1 | year)",

  "Cold extremes increase thermoregulatory demand in chicks, increasing mortality risk",
  "success ~ min_temp + (1 | year)",

  # ---- Rain ----
  "**Rain**", "",
  "Prolonged rainfall reduces adult foraging efficiency, limiting food delivery to chicks and reducing breeding success",
  "success ~ rain_days + (1 | year)",

  "Intense rainfall events cause acute nest disturbance and chick exposure, reducing breeding success",
  "success ~ max_rain + (1 | year)",

  "Overall wet years reduce provisioning efficiency across the breeding season, lowering breeding success",
  "success ~ total_rain + (1 | year)",

  # ---- Wind ----
  "**Wind**", "",
  "Extreme winds increase nest exposure and disrupt provisioning, reducing chick survival",
  "success ~ max_wind + (1 | year)",

  # ---- Hail ----
  "**Hail**", "",
  "Severe hail events increase nest destruction and chick mortality, reducing breeding success",
  "success ~ hail_days + (1 | year)",

  # ---- Joint Effects ----
  "**Joint effects**", "",
  "Severe storm exposure increases nest destruction and chick mortality, reducing breeding success",
  "success ~ hail_days + max_wind + (1 | year)",

  "Prolonged wet conditions combined with storm events increase chick exposure and limit provisioning, reducing breeding success",
  "success ~ rain_days + hail_days + (1 | year)",

  "Heat stress combined with prolonged wet conditions reduces chick thermoregulation and food delivery, lowering breeding success",
  "success ~ max_temp + rain_days + (1 | year)",

  # ---- Interactive Effects ----
  "**Interactive effects**", "",
  "The negative effect of heat stress on breeding success is amplified during persistently wet conditions that limit adult foraging",
  "success ~ max_temp * rain_days + (1 | year)",

  "Cold stress on chicks is amplified during extreme wind events due to increased exposure and heat loss, reducing breeding success",
  "success ~ min_temp * max_wind + (1 | year)"
)

kable(
  objective2_table,
  align = c("l", "l"),
  caption = "Objective 2 candidate model set for breeding success. All models are fitted as binomial GLMMs: cbind(success_nests, failed_nests) with a random intercept for year (1 | year)"
)
```

success ~ 1 + (1 | year)

```{r}
library(lme4)

success_df <- success_df |> mutate(year = factor(year))

m0 <- glmer(
  cbind(success_nests, failed_nests) ~ 1 + (1 | year),
  family = binomial,
  data = success_df
)
summary(m0)

```

```{r}
library(lme4)

success_df <- success_df |> dplyr::mutate(year = factor(year))

# Baseline (null) model

m0_success <- glmer(
  cbind(success_nests, failed_nests) ~ 1 + (1 | year),
  family = binomial,
  data = success_df
)

# Single predictor models

m_succ_maxT <- glmer(
  cbind(success_nests, failed_nests) ~ z_max_temp + (1 | year),
  family = binomial, data = success_df
)

m_succ_minT <- glmer(
  cbind(success_nests, failed_nests) ~ z_min_temp + (1 | year),
  family = binomial, data = success_df
)

m_succ_rainD <- glmer(
  cbind(success_nests, failed_nests) ~ z_rain_days + (1 | year),
  family = binomial, data = success_df
)

m_succ_maxR <- glmer(
  cbind(success_nests, failed_nests) ~ z_max_rain + (1 | year),
  family = binomial, data = success_df
)

m_succ_totR <- glmer(
  cbind(success_nests, failed_nests) ~ z_total_rain + (1 | year),
  family = binomial, data = success_df
)

m_succ_maxW <- glmer(
  cbind(success_nests, failed_nests) ~ z_max_wind + (1 | year),
  family = binomial, data = success_df
)

m_succ_hail <- glmer( 
  cbind(success_nests, failed_nests) ~ z_hail_days + (1 | year),
  family = binomial, data = success_df
)

# Joint effects

m_succ_hailW <- glmer(
  cbind(success_nests, failed_nests) ~ z_hail_days + z_max_wind + (1 | year),
  family = binomial, data = success_df
)

m_succ_rainH <- glmer(
  cbind(success_nests, failed_nests) ~ z_rain_days + z_hail_days + (1 | year),
  family = binomial, data = success_df
)

m_succ_heatR <- glmer(
  cbind(success_nests, failed_nests) ~ z_max_temp + z_rain_days + (1 | year),
  family = binomial, data = success_df
)

# Interactions

m_succ_int_heat_rain <- glmer(
  cbind(success_nests, failed_nests) ~ z_max_temp * z_rain_days + (1 | year),
  family = binomial, data = success_df
)

m_succ_int_cold_wind <- glmer(
  cbind(success_nests, failed_nests) ~ z_min_temp * z_max_wind + (1 | year),
  family = binomial, data = success_df
)

```

```{r}

# Candidate set + AIC

library(AICcmodavg)

cand_success <- list(
  null_re      = m0_success,

  max_temp     = m_succ_maxT,
  min_temp     = m_succ_minT,
  rain_days    = m_succ_rainD,
  max_rain     = m_succ_maxR,
  total_rain   = m_succ_totR,
  max_wind     = m_succ_maxW,
  hail_days    = m_succ_hail,

  hail_maxW    = m_succ_hailW,
  rain_hail    = m_succ_rainH,
  maxT_rainD   = m_succ_heatR,

  int_heatRain = m_succ_int_heat_rain,
  int_coldWind = m_succ_int_cold_wind
)

aic_success <- aictab(
  cand.set  = cand_success,
  modnames  = names(cand_success)
)

aic_success

```


```{r}
vc_year <- function(mod) {
  vc <- as.data.frame(VarCorr(mod))
  vc$vcov[vc$grp == "year"][1]
}

v0     <- vc_year(m0_success)
v_minT <- vc_year(m_succ_minT)

prop_between_year_explained <- (v0 - v_minT) / v0
prop_between_year_explained

```

### Figures and tables 

```{r}
library(dplyr)
library(tibble)
library(purrr)
library(knitr)
library(kableExtra)
library(lme4)

aic_df <- as.data.frame(aic_success)

if ("Modnames" %in% names(aic_df)) {
  aic_df <- aic_df |> mutate(model_id = Modnames)
} else {
  aic_df <- tibble::rownames_to_column(aic_df, "model_id")
}

table_success <- aic_df |>
  rename(
    K = K,
    AICc = AICc,
    `ΔAICc` = Delta_AICc,
    w = AICcWt
  ) |>
  dplyr::select(model_id, K, AICc, `ΔAICc`, w) |>
  arrange(`ΔAICc`)

vc_year <- function(mod) {
  vc <- as.data.frame(VarCorr(mod))
  vc$vcov[vc$grp == "year"][1]
}

v0 <- vc_year(m0_success)

var_expl_tbl <- tibble(
  model_id = names(cand_success),
  `Variance explained` = map_dbl(cand_success, ~ {
    v <- vc_year(.x)
    (v0 - v) / v0
  })
) |>
  mutate(`Variance explained` = round(`Variance explained`, 3))

table_success <- table_success |>
  left_join(var_expl_tbl, by = "model_id")

get_slope_se <- function(mod) {
  cf <- summary(mod)$coefficients
  if (nrow(cf) == 2) {
    paste0(round(cf[2, 1], 3), " (", round(cf[2, 2], 3), ")")
  } else {
    ""
  }
}

slope_tbl <- tibble(
  model_id = table_success$model_id,
  `slope (SE)` = map_chr(table_success$model_id, ~ get_slope_se(cand_success[[.x]]))
)

table_success <- table_success |>
  left_join(slope_tbl, by = "model_id") |>
  mutate(
    AICc = round(AICc, 2),
    `ΔAICc` = round(`ΔAICc`, 2),
    w = round(w, 3)
  )

group_order <- c("Baseline", "Temperature", "Rain", "Wind", "Hail", "Joint effects", "Interactions")

model_group_succ <- function(m) {
  case_when(
    m %in% c("null_re", "null", "null_success") ~ "Baseline",
    m %in% c("min_temp", "max_temp") ~ "Temperature",
    m %in% c("rain_days", "max_rain", "total_rain") ~ "Rain",
    m %in% c("max_wind") ~ "Wind",
    m %in% c("hail_days") ~ "Hail",
    m %in% c("hail_maxW", "rain_hail", "maxT_rainD") ~ "Joint effects",
    m %in% c("int_heatRain", "int_coldWind") ~ "Interactions",
    TRUE ~ "Joint effects"
  )
}

neat_succ <- function(x) {
  recode(
    x,
    "null_re"      = "Intercept only",
    "min_temp"     = "Minimum temperature",
    "max_temp"     = "Maximum temperature",
    "rain_days"    = "Rainy days",
    "max_rain"     = "Maximum daily rainfall",
    "total_rain"   = "Total rainfall",
    "max_wind"     = "Maximum wind speed",
    "hail_days"    = "Hail days",
    "hail_maxW"    = "Hail days + max wind speed",
    "rain_hail"    = "Rainy days + hail days",
    "maxT_rainD"   = "Max temperature + rainy days",
    "int_heatRain" = "Max temperature × rainy days",
    "int_coldWind" = "Min temperature × max wind speed",
    .default = x
  )
}

table_success_clean <- table_success |>
  mutate(
    Group = model_group_succ(model_id),
    Model = neat_succ(model_id),
    Group = factor(Group, levels = group_order)
  ) |>
  arrange(Group, `ΔAICc`) |>
  dplyr::select(Group, Model, K, AICc, `ΔAICc`, w, `Variance explained`, `slope (SE)`)

group_sizes <- table_success_clean |>
  count(Group, name = "n") |>
  filter(n > 0) |>
  mutate(
    start = cumsum(lag(n, default = 0)) + 1,
    end = cumsum(n)
  )

tbl_succ <- kable(
  table_success_clean |> dplyr::select(-Group),
  caption = "Table 3:Model selection results for breeding success (binomial GLMMs with a random intercept for year). Variance explained is the proportional reduction in the estimated between-year variance relative to the null model. Slope (SE) is shown only for single-predictor models.",
  align = "l"
) |>
  kable_styling(full_width = FALSE)

for (i in seq_len(nrow(group_sizes))) {
  tbl_succ <- tbl_succ |>
    pack_rows(
      as.character(group_sizes$Group[i]),
      group_sizes$start[i],
      group_sizes$end[i]
    )
}

tbl_succ


```

```{r}

minT_model <- m_succ_minT


success_df_plot <- success_df |>
  mutate(
    success_rate = success_nests / (success_nests + failed_nests),
    year_num = as.numeric(as.character(year))
  )

yrs <- sort(unique(success_df_plot$year_num[is.finite(success_df_plot$year_num)]))
breaks_5y <- yrs[seq(1, length(yrs), by = 5)]  #

ggplot(success_df_plot, aes(x = year_num, y = success_rate)) +
  geom_point(size = 2, colour = "grey30") +
  geom_smooth(
    method = "lm",
    se = TRUE,
    colour = "grey30",
    fill = "grey85"
  ) +
  scale_y_continuous(limits = c(0, 1)) +
  scale_x_continuous(breaks = breaks_5y) +
  labs(
    x = "Year",
    y = "Breeding success",
    title = "Annual breeding success (proportion of successful nests) 
of White-backed Vultures"
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())

```


```{r}
obs_df <- success_df |>
  mutate(
    success_rate = success_nests / (success_nests + failed_nests),
    se = sqrt(success_rate * (1 - success_rate) /
                (success_nests + failed_nests))
  )

```

```{r}
minT_model <- m_succ_minT

pred_df <- success_df |>
  mutate(
    pred = predict(
      minT_model,
      newdata = success_df,
      type = "response",
      re.form = NA
    )
  )

```

```{r}

obs_df <- success_df |>
  mutate(
    year_num = as.numeric(gsub("[^0-9]", "", as.character(year))),
    success_rate = success_nests / (success_nests + failed_nests),
    se = sqrt(success_rate * (1 - success_rate) / (success_nests + failed_nests))
  )

minT_model <- m_succ_minT

pred_df <- success_df |>
  mutate(
    year_num = as.numeric(gsub("[^0-9]", "", as.character(year))),
    pred = predict(minT_model, newdata = success_df, type = "response", re.form = NA)
  )


ggplot() +
  geom_point(
    data = obs_df,
    aes(x = year_num, y = success_rate),
    size = 2, shape = 21, fill = "white", colour = "grey30"
  ) +
  geom_errorbar(
    data = obs_df,
    aes(x = year_num,
        ymin = success_rate - se,
        ymax = success_rate + se),
    width = 0, colour = "grey30"
  ) +
  geom_line(
    data = pred_df,
    aes(x = year_num, y = pred),
    linewidth = 1, colour = "black"
  ) +
  scale_y_continuous(limits = c(0, 1)) +
  scale_x_continuous(breaks = seq(1995, 2025, by = 5)) +
  labs(
    x = "Year",
    y = "Breeding success",
    title = "Observed and temperature-predicted breeding success",
    subtitle = "Points show annual observed success (± SE); line shows predictions from the minimum temperature model"
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())

```
figure shows that years with warmer minimum temperatures tend to have slightly higher breeding success, but temperature alone does not explain most of the year-to-year variation.
Given the temperature in each year, this is what the model predicts breeding success should be


```{r}
succ_clean <- succ_clean %>%
  mutate(dAICc_plot = if_else(model_id == "min_temp", 0.05, dAICc))

ggplot() +
  geom_col(
    data = succ_clean,
    aes(x = label, y = dAICc_plot),
    width = 0.7,
    fill = "grey75"
  ) +
  geom_col(
    data = succ_clean %>% filter(model_id == "min_temp"),
    aes(x = label, y = dAICc_plot),
    width = 0.7,
    fill = "steelblue"
  ) +
  coord_flip() +
  geom_hline(yintercept = 2, linetype = "dashed") +
  labs(
    title = "Model support for breeding success",
    subtitle = "ΔAICc values; best model visually offset",
    x = NULL,
    y = expression(Delta*AIC[c])
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())


```

```{r}
ggplot() +

  # observed annual success (faded)
  geom_point(
    data = success_df,
    aes(
      x = z_min_temp,
      y = success_nests / (success_nests + failed_nests)
    ),
    colour = "grey50",
    alpha = 0.5,
    size = 2
  ) +

  # model prediction
  geom_ribbon(
    data = pred_minT,
    aes(x = x, ymin = conf.low, ymax = conf.high),
    fill = "#1f78b4",
    alpha = 0.15
  ) +
  geom_line(
    data = pred_minT,
    aes(x = x, y = predicted),
    colour = "#1f78b4",
    linewidth = 1.4
  ) +

  labs(
    x = "Minimum temperature (standardised)",
    y = "Breeding success",
    title = "Breeding success increases with warmer minimum temperatures"
  ) +

  theme_bw() +
  theme(panel.grid = element_blank())

```

   title = "Breeding success increases with warmer minimum temperatures"




--------------------------------------------------------------------------------

### Objective 3

```{r}
hist(timing_weather_60$lay_DOY)
qqnorm(timing_weather_60$lay_DOY)
qqline(timing_weather_60$lay_DOY)

```


```{r}
objective3_table <- tribble(
  ~`Hypothesis / justification`, ~Model,

  # ---- Temperature (pre-laying cues) ----
  "**Temp (pre-laying)**", "",
  "Short-term warm conditions prior to laying may act as a cue for the initiation of breeding.",
  "lay_DOY ~ mean_temp_60",

  "Cold pre-laying conditions delay breeding due to increased energetic costs",
  "lay_DOY ~ min_temp_60",


  # ---- Rain (pre-laying cues) ----
  "**Rain (pre-laying)**", "",
  "Prolonged wet conditions prior to laying delay breeding by limiting foraging efficiency",
  "lay_DOY ~ rain_days_60",

  "Higher rainfall prior to laying signals improved food availability and advances breeding timing",
  "lay_DOY ~ total_rain_60",

  # ---- Wind (pre-laying flight conditions) ----
  "**Wind (pre-laying)**", "",
  "Persistent windy conditions prior to laying increase flight costs and delay breeding timing",
  "lay_DOY ~ mean_wind_60",

  # ---- Lagged effects (carry-over cues) ----
  "**Lagged effects (previous year)**", "",
  "Higher rainfall in the previous year improves food availability and adult condition entering the breeding season, allowing vultures to initiate breeding earlier",
  "lay_DOY ~ lag_total_rain",

  "Prolonged wet conditions in the previous year may influence adult condition and carry over to affect laying timing",
  "lay_DOY ~ lag_rain_days",

  "Thermal conditions in the previous year influence physiological state entering the breeding season",
  "lay_DOY ~ lag_mean_temp",

  # ---- Joint effects ----
  "**Joint effects**", "",
  "Temperature and rainfall cues prior to laying jointly influence breeding timing",
  "lay_DOY ~ mean_temp_60 + rain_days_60",

  "Carry-over effects from the previous year interact with current pre-laying rainfall cues",
  "lay_DOY ~ lag_total_rain + rain_days_60",

  "Previous-year rainfall and current temperature jointly influence breeding timing",
  "lay_DOY ~ lag_total_rain + mean_temp_60",

  # ---- Interactive effects ----
  "**Interactive effects**", "",
  "The effect of temperature cues on breeding timing depends on pre-laying rainfall conditions",
  "lay_DOY ~ mean_temp_60 * rain_days_60",

  "Carry-over effects from the previous year modify responses to current pre-laying temperature cues",
  "lay_DOY ~ lag_total_rain * mean_temp_60"
)

kable(
  objective3_table,
  align = c("l", "l"),
  caption = "Objective 3 candidate model set for breeding timing (laying date, day of year)."
)
```

```{r}

# 60 days prior
timing_weather_60 <- timing_weather_60 |>
  left_join(
    weather_yearly_lag |>
      dplyr::select(
        YEAR,
        lag_total_rain,
        lag_rain_days,
        lag_mean_temp
      ),
    by = c("year" = "YEAR")
  )

# 30 days prior
timing_weather_30 <- timing_weather_30 |>
  left_join(
    weather_yearly_lag |>
      dplyr::select(
        YEAR,
        lag_total_rain,
        lag_rain_days,
        lag_mean_temp
      ),
    by = c("year" = "YEAR")
  )

```


```{r}

cand_timing_30 <- list(

  meanT_30   = lm(lay_DOY ~ mean_temp_30, data = timing_weather_30),
  maxT_30    = lm(lay_DOY ~ max_temp_30,  data = timing_weather_30),
  minT_30    = lm(lay_DOY ~ min_temp_30,  data = timing_weather_30),

  rainDays_30 = lm(lay_DOY ~ rain_days_30,  data = timing_weather_30),
  totalR_30   = lm(lay_DOY ~ total_rain_30, data = timing_weather_30),

  meanW_30 = lm(lay_DOY ~ mean_wind_30, data = timing_weather_30),
  maxW_30  = lm(lay_DOY ~ max_wind_30,  data = timing_weather_30),

  # lagged (previous year)
  lagTotR  = lm(lay_DOY ~ lag_total_rain, data = timing_weather_30),
  lagRainD = lm(lay_DOY ~ lag_rain_days,  data = timing_weather_30),
  lagMeanT = lm(lay_DOY ~ lag_mean_temp,  data = timing_weather_30),

  # additive
  temp_rain = lm(lay_DOY ~ mean_temp_30 + rain_days_30, data = timing_weather_30),
  temp_wind = lm(lay_DOY ~ mean_temp_30 + mean_wind_30, data = timing_weather_30),
  rain_wind = lm(lay_DOY ~ rain_days_30 + mean_wind_30, data = timing_weather_30),

  # interactions
  temp_x_rain = lm(lay_DOY ~ mean_temp_30 * rain_days_30, data = timing_weather_30),
  minT_x_wind = lm(lay_DOY ~ min_temp_30 * mean_wind_30, data = timing_weather_30),
  lagR_x_temp = lm(lay_DOY ~ lag_total_rain * mean_temp_30, data = timing_weather_30)
)

```


```{r}

aic_timing_30 <- aictab(
  cand.set = cand_timing_30,
  modnames = names(cand_timing_30)
)

```

```{r}

cand_timing_60 <- list(

  meanT_60   = lm(lay_DOY ~ mean_temp_60, data = timing_weather_60),
  maxT_60    = lm(lay_DOY ~ max_temp_60,  data = timing_weather_60),
  minT_60    = lm(lay_DOY ~ min_temp_60,  data = timing_weather_60),

  rainDays_60 = lm(lay_DOY ~ rain_days_60,  data = timing_weather_60),
  totalR_60   = lm(lay_DOY ~ total_rain_60, data = timing_weather_60),

  meanW_60 = lm(lay_DOY ~ mean_wind_60, data = timing_weather_60),
  maxW_60  = lm(lay_DOY ~ max_wind_60,  data = timing_weather_60),

  # lagged (previous year)
  lagTotR  = lm(lay_DOY ~ lag_total_rain, data = timing_weather_60),
  lagRainD = lm(lay_DOY ~ lag_rain_days,  data = timing_weather_60),
  lagMeanT = lm(lay_DOY ~ lag_mean_temp,  data = timing_weather_60),

  # additive
  temp_rain = lm(lay_DOY ~ mean_temp_60 + rain_days_60, data = timing_weather_60),
  temp_wind = lm(lay_DOY ~ mean_temp_60 + mean_wind_60, data = timing_weather_60),
  rain_wind = lm(lay_DOY ~ rain_days_60 + mean_wind_60, data = timing_weather_60),

  # interactions
  temp_x_rain = lm(lay_DOY ~ mean_temp_60 * rain_days_60, data = timing_weather_60),
  minT_x_wind = lm(lay_DOY ~ min_temp_60 * mean_wind_60, data = timing_weather_60),
  lagR_x_temp = lm(lay_DOY ~ lag_total_rain * mean_temp_60, data = timing_weather_60)
)

```

```{r}

aic_timing_60 <- aictab(
  cand.set = cand_timing_60,
  modnames = names(cand_timing_60)
)

```

```{r}
aic_timing_30
summary(cand_timing_30$temp_x_rain)$r.squared


aic_timing_60
summary(cand_timing_60$temp_x_rain)$r.squared

```

```{r}
m_year_trend <- lm(lay_DOY ~ year, data = timing_weather_30)
summary(m_year_trend)

``` 

```{r}
summary(m_year_trend)$r.squared

```

```{r}
m_year_trend60 <- lm(lay_DOY ~ year, data = timing_weather_60)
summary(m_year_trend60)

```


### Figures and Tables

```{r}
cand_timing_30 <- cand_timing_30[names(cand_timing_30) != "null"]
cand_timing_60 <- cand_timing_60[names(cand_timing_60) != "null"]

build_obj3_base <- function(cand_list){

  tab <- tibble::tibble(
    model_id  = names(cand_list),
    Deviance  = sapply(cand_list, stats::deviance),
    K         = sapply(cand_list, function(m) length(stats::coef(m))),
    AICc      = sapply(cand_list, AICcmodavg::AICc),
    R2        = sapply(cand_list, function(m) summary(m)$r.squared),
    `slope (SE)` = purrr::imap_chr(cand_list, ~{
      broom::tidy(.x) |>
        dplyr::filter(term != "(Intercept)") |>
        dplyr::mutate(txt = paste0(
          sprintf("%.3f", estimate),
          " (", sprintf("%.3f", std.error), ")"
        )) |>
        dplyr::pull(txt) |>
        paste(collapse = "; ")
    })
  ) |>
    dplyr::arrange(AICc) |>
    dplyr::mutate(
      `ΔAICc` = AICc - min(AICc),
      w = exp(-0.5 * `ΔAICc`) / sum(exp(-0.5 * `ΔAICc`)),
      Deviance = round(Deviance, 3),
      AICc = round(AICc, 2),
      `ΔAICc` = round(`ΔAICc`, 2),
      w = round(w, 3),
      R2 = round(R2, 3)
    ) |>
    dplyr::select(
      model_id, Deviance, K, AICc, `ΔAICc`, w, R2, `slope (SE)`
    )

  tab
}

model_key <- tibble::tribble(
  ~model_id,      ~Group,               ~Model,
  "meanT_30",     "Temperature",        "Mean temperature (30 days)",
  "maxT_30",      "Temperature",        "Maximum temperature (30 days)",
  "minT_30",      "Temperature",        "Minimum temperature (30 days)",

  "rainDays_30",  "Rain",               "Rainy days (30 days)",
  "totalR_30",    "Rain",               "Total rainfall (30 days)",

  "meanW_30",     "Wind",               "Mean wind speed (30 days)",
  "maxW_30",      "Wind",               "Maximum wind speed (30 days)",

  "meanT_60",     "Temperature",        "Mean temperature (60 days)",
  "maxT_60",      "Temperature",        "Maximum temperature (60 days)",
  "minT_60",      "Temperature",        "Minimum temperature (60 days)",

  "rainDays_60",  "Rain",               "Rainy days (60 days)",
  "totalR_60",    "Rain",               "Total rainfall (60 days)",

  "meanW_60",     "Wind",               "Mean wind speed (60 days)",
  "maxW_60",      "Wind",               "Maximum wind speed (60 days)",

  "lagTotR",      "Lagged effects",     "Previous year's total rainfall",
  "lagRainD",     "Lagged effects",     "Previous year's rainy days",
  "lagMeanT",     "Lagged effects",     "Previous year's mean temperature",

  "temp_rain",    "Joint effects",      "Mean temperature + rainy days",
  "temp_wind",    "Joint effects",      "Mean temperature + mean wind speed",
  "rain_wind",    "Joint effects",      "Rainy days + mean wind speed",

  "temp_x_rain",  "Interactive effects","Mean temperature × rainy days",
  "minT_x_wind",  "Interactive effects","Minimum temperature × mean wind speed",
  "lagR_x_temp",  "Interactive effects","Previous year's rainfall × mean temperature"
)

make_grouped_table <- function(cand_list, caption_text){

  group_order <- c(
    "Rain", "Temperature", "Wind",
    "Lagged effects", "Joint effects", "Interactive effects", "Other"
  )

  tab <- build_obj3_base(cand_list) |>
    dplyr::left_join(model_key, by = "model_id") |>
    dplyr::mutate(
      Group = dplyr::coalesce(Group, "Other"),
      Model = dplyr::coalesce(Model, model_id),
      Group = factor(Group, levels = group_order)
    ) |>
    dplyr::arrange(Group, AICc) |>
    dplyr::select(Group, Model, Deviance, K, AICc, `ΔAICc`, w, R2, `slope (SE)`)

  group_sizes <- tab |>
    dplyr::count(Group, name = "n") |>
    dplyr::filter(n > 0) |>
    dplyr::mutate(
      start = cumsum(dplyr::lag(n, default = 0)) + 1,
      end = cumsum(n)
    )

  kb <- knitr::kable(
    tab |> dplyr::select(-Group),
    caption = caption_text,
    align = c("l","r","r","r","r","r","r","r","l"),
 Twbooktabs = TRUE
  ) |>
    kableExtra::kable_styling(full_width = TRUE)

  for(i in seq_len(nrow(group_sizes))){
    kb <- kb |>
      kableExtra::pack_rows(
        as.character(group_sizes$Group[i]),
        group_sizes$start[i],
        group_sizes$end[i],
        bold = TRUE
      )
  }

  kb
}

make_grouped_table(
  cand_timing_30,
  "Table 4. Models explaining laying date (day of year) at Dronfield using 30-day pre-laying weather cues. K = number of parameters; AICc = small-sample AIC; ΔAICc = difference from the best model; w = Akaike weight. R² is shown for all models; slope (SE) is reported for each weather predictor."
)

make_grouped_table(
  cand_timing_60,
  "Table 5. Models explaining laying date (day of year) at Dronfield using 60-day pre-laying weather cues. K = number of parameters; AICc = small-sample AIC; ΔAICc = difference from the best model; w = Akaike weight. R² is shown for all models; slope (SE) is reported for each weather predictor."
)

```





```{r}
ggplot(timing_weather_60, aes(x = lay_DOY)) +
  geom_histogram(bins = 15, fill = "grey70", colour = "black") +
  labs(
    x = "Laying date (day of year)",
    y = "Frequency",
    title = "Distribution of laying dates"
  ) +
  theme_bw() +
  theme(panel.grid = element_blank())

```

```{r}
timing_weather_30_filt <- timing_weather_30 |>
  dplyr::filter(year >= 1993, year <= 2024)

ggplot(timing_weather_30_filt, aes(x = year, y = lay_DOY)) +
  geom_point(
    size = 1.8,
    colour = "grey30",
    alpha = 0.6
  ) +
  geom_smooth(
    method = "lm",
    se = TRUE,
    colour = "grey",
    linewidth = 1
  ) +
  scale_x_continuous(
    breaks = seq(1995, 2025, by = 5),
    limits = c(1993, 2024)
  ) +
  labs(
    x = "Year",
    y = "Laying date (day of year)",
    title = "Annual variation in laying date at Dronfield"
  ) +
  theme_bw() +
  theme(
    panel.grid = element_blank()
  )+
  geom_jitter(
  width = 0.2,
  height = 0,
  size = 1.6,
  colour = "grey30",
  alpha = 0.6
)



```

```{r}
# Figure 3.3: Temperature × rainfall interaction with prediction ribbons

m_int <- cand_timing_30$temp_x_rain

df <- timing_weather_30 |>
  dplyr::filter(year >= 1993, year <= 2024)

# rainfall quantiles
rain_q <- quantile(df$rain_days_30,
                   probs = c(0.25, 0.5, 0.75),
                   na.rm = TRUE)

# prediction grid
newdat <- expand.grid(
  mean_temp_30 = seq(
    min(df$mean_temp_30, na.rm = TRUE),
    max(df$mean_temp_30, na.rm = TRUE),
    length.out = 80
  ),
  rain_days_30 = as.numeric(rain_q)
)

# predictions + SE
pred <- predict(m_int, newdata = newdat, se.fit = TRUE)

newdat$fit <- pred$fit
newdat$lo  <- pred$fit - 1.96 * pred$se.fit
newdat$hi  <- pred$fit + 1.96 * pred$se.fit

newdat$Rain_group <- factor(
  newdat$rain_days_30,
  labels = c("Low rainfall (25%)",
             "Medium rainfall (50%)",
             "High rainfall (75%)")
)

# plot
ggplot(df, aes(x = mean_temp_30, y = lay_DOY)) +
  geom_point(
    colour = "grey75",
    size = 1.6,
    alpha = 0.35
  ) +
  geom_ribbon(
    data = newdat,
    aes(
      x = mean_temp_30,
      ymin = lo,
      ymax = hi,
      group = Rain_group
    ),
    alpha = 0.12,
    inherit.aes = FALSE
  ) +
  geom_line(
    data = newdat,
    aes(
      x = mean_temp_30,
      y = fit,
      linetype = Rain_group
    ),
    linewidth = 1.2,
    inherit.aes = FALSE
  ) +
  labs(
    x = "Mean temperature (30 days pre-laying)",
    y = "Laying date (day of year)",
    linetype = "Rainfall conditions",
    title = "Temperature–rainfall interaction predicts laying date"
  ) +
  theme_bw() +
  theme(
    panel.grid = element_blank(),
    legend.position = "right"
  )

```
Laying date advanced with increasing pre-laying temperature, but this effect was contingent on rainfall conditions, indicating that thermal cues did not operate independently of broader environmental context. 


```{r}
library(dplyr)
library(ggplot2)
library(forcats)

# ---- short labels
model_labels <- tibble::tribble(
  ~model_id,      ~label_short,
  "meanT_30",     "Mean T (30d)",
  "maxT_30",      "Max T (30d)",
  "minT_30",      "Min T (30d)",
  "rainDays_30",  "Rain days (30d)",
  "totalR_30",    "Total rain (30d)",
  "meanW_30",     "Mean wind (30d)",
  "maxW_30",      "Max wind (30d)",

  "meanT_60",     "Mean T (60d)",
  "maxT_60",      "Max T (60d)",
  "minT_60",      "Min T (60d)",
  "rainDays_60",  "Rain days (60d)",
  "totalR_60",    "Total rain (60d)",
  "meanW_60",     "Mean wind (60d)",
  "maxW_60",      "Max wind (60d)",

  "lagTotR",      "Lag total rain",
  "lagRainD",     "Lag rain days",
  "lagMeanT",     "Lag mean T",

  "temp_rain",    "Mean T + rain days",
  "temp_wind",    "Mean T + mean wind",
  "rain_wind",    "Rain days + mean wind",

  "temp_x_rain",  "Mean T × rain days",
  "minT_x_wind",  "Min T × mean wind",
  "lagR_x_temp",  "Lag rain × mean T"
)

plot_daic <- function(cand_list, period_label){
  tab <- build_obj3_base(cand_list) |>
    left_join(model_labels, by = "model_id") |>
    mutate(
      label_short = coalesce(label_short, model_id),
      is_best = (`ΔAICc` == min(`ΔAICc`)),
      label_short = fct_reorder(label_short, `ΔAICc`, .desc = FALSE)

    )

  ggplot(tab, aes(x = label_short, y = `ΔAICc`, fill = is_best)) +
    geom_col(width = 0.75) +
    coord_flip() +
    scale_fill_manual(values = c(`TRUE` = "steelblue", `FALSE` = "grey70"), guide = "none") +
    geom_hline(yintercept = 2, linetype = "dashed") +
    labs(
      x = NULL,
      y = expression(Delta*AIC[c]),
      title = paste0("Objective 3: Model support (", period_label, ")"),
      subtitle = "Dashed line = ΔAICc = 2 (models with substantial support)"
    ) +
    theme_bw() +
    theme(panel.grid = element_blank())
}

p_daic_30 <- plot_daic(cand_timing_30, "30-day cues")
p_daic_60 <- plot_daic(cand_timing_60, "60-day cues")

p_daic_30
p_daic_60


```





```{r}
library(dplyr)
library(ggplot2)

plot_temp_rain_clean <- function(model, data,
                                 xvar = "mean_temp_30",
                                 zvar = "rain_days_30",
                                 yvar = "lay_DOY",
                                 period_label = "30-day cues",
                                 zoom_y = TRUE){

  # choose representative low/med/high rainfall values
  qs <- quantile(data[[zvar]], probs = c(0.2, 0.5, 0.8), na.rm = TRUE)

  grid <- expand.grid(
    x = seq(min(data[[xvar]], na.rm = TRUE), max(data[[xvar]], na.rm = TRUE), length.out = 100),
    z = qs
  )
  names(grid) <- c(xvar, zvar)

  grid$pred <- predict(model, newdata = grid)
  grid$rain_level <- factor(
    c("Low rain", "Medium rain", "High rain")[match(grid[[zvar]], qs)],
    levels = c("Low rain", "Medium rain", "High rain")
  )

  p <- ggplot(data, aes(x = .data[[xvar]], y = .data[[yvar]])) +
    geom_point(size = 1.6, alpha = 0.35, colour = "grey25") +
    geom_line(
      data = grid,
      aes(x = .data[[xvar]], y = pred, linetype = rain_level),
      linewidth = 1.1,
      colour = "black"
    ) +
    scale_linetype_manual(values = c("solid", "dashed", "dotdash")) +
    labs(
      title = paste0("Breeding timing  (", period_label, ")"),
      subtitle = "Predicted laying date across temperature at low / medium / high rainfall",
      x = "Mean temperature (30 days prior)",
      y = "Laying date (DOY)",
      linetype = NULL
    ) +
    theme_bw() +
    theme(
      panel.grid = element_blank(),
      plot.title = element_text(size = 12, face = "bold"),
      plot.subtitle = element_text(size = 9),
      axis.title = element_text(size = 9),
      axis.text = element_text(size = 9),
      legend.position = "bottom",
      legend.box = "horizontal"
    )

  if (zoom_y) {
    # zoom to central range so a few outliers don't destroy the plot
    yl <- quantile(data[[yvar]], probs = c(0.02, 0.98), na.rm = TRUE)
    p <- p + coord_cartesian(ylim = yl)
  }

  p
}

# USE IT (30-day best interaction model)
plot_temp_rain_clean(
  model = cand_timing_30$temp_x_rain,
  data  = timing_weather_30,
  xvar  = "mean_temp_30",
  zvar  = "rain_days_30",
  period_label = "30-day cues",
  zoom_y = TRUE
)

```
```{r}
library(dplyr)
library(ggplot2)

plot_temp_rain_clean <- function(model, data,
                                 xvar,
                                 zvar,
                                 yvar = "lay_DOY",
                                 period_label = "",
                                 xlab = NULL,
                                 zlab = NULL,
                                 zoom_y = TRUE){

  # drop rows missing the needed columns (prevents Inf/-Inf)
  dd <- data |>
    dplyr::filter(
      !is.na(.data[[xvar]]),
      !is.na(.data[[zvar]]),
      !is.na(.data[[yvar]])
    )

  # choose representative low/med/high values of the moderator (zvar)
  qs <- quantile(dd[[zvar]], probs = c(0.2, 0.5, 0.8), na.rm = TRUE)

  grid <- expand.grid(
    x = seq(min(dd[[xvar]], na.rm = TRUE), max(dd[[xvar]], na.rm = TRUE), length.out = 100),
    z = qs
  )
  names(grid) <- c(xvar, zvar)

  grid$pred <- predict(model, newdata = grid)

  # nice legend labels
  z_show <- ifelse(is.null(zlab), zvar, zlab)
  grid$level <- factor(
    c("Low", "Medium", "High")[match(grid[[zvar]], qs)],
    levels = c("Low", "Medium", "High")
  )

  p <- ggplot(dd, aes(x = .data[[xvar]], y = .data[[yvar]])) +
    geom_point(size = 1.6, alpha = 0.35, colour = "grey25") +
    geom_line(
      data = grid,
      aes(x = .data[[xvar]], y = pred, linetype = level),
      linewidth = 1.1,
      colour = "black"
    ) +
    scale_linetype_manual(
      values = c("solid", "dashed", "dotdash"),
      labels = paste0(levels(grid$level), " ", z_show)
    ) +
    labs(
      title = paste0("Breeding timing (", period_label, ")"),
      subtitle = "Predicted laying date across temperature at low / medium / high rainfall",
      x = ifelse(is.null(xlab), xvar, xlab),
      y = "Laying date (DOY)",
      linetype = NULL
    ) +
    theme_bw() +
    theme(
      panel.grid = element_blank(),
      plot.title = element_text(size = 12, face = "bold"),
      plot.subtitle = element_text(size = 9),
      axis.title = element_text(size = 9),
      axis.text = element_text(size = 9),
      legend.position = "bottom",
      legend.box = "horizontal"
    )

  if (zoom_y) {
    yl <- quantile(dd[[yvar]], probs = c(0.02, 0.98), na.rm = TRUE)
    p <- p + coord_cartesian(ylim = yl)
  }

  p
}

# -----------------------------
# 30 DAYS: mean_temp_30 × rain_days_30
# -----------------------------
p_timing_30 <- plot_temp_rain_clean(
  model = cand_timing_30$temp_x_rain,
  data  = timing_weather_30,
  xvar  = "mean_temp_30",
  zvar  = "rain_days_30",
  period_label = "30-day cues",
  xlab = "Mean temperature (30 days prior)",
  zlab = "Rainy days (30 days prior)",
  zoom_y = TRUE
)

# -----------------------------
# 60 DAYS: mean_temp_60 × rain_days_60
# -----------------------------
p_timing_60 <- plot_temp_rain_clean(
  model = cand_timing_60$temp_x_rain,
  data  = timing_weather_60,
  xvar  = "mean_temp_60",
  zvar  = "rain_days_60",
  period_label = "60-day cues",
  xlab = "Mean temperature (60 days prior)",
  zlab = "Rainy days (60 days prior)",
  zoom_y = TRUE
)

p_timing_30
p_timing_60

```



## DAGs

```{r}
install.packages("ggdag")
install.packages("dagitty")

library(ggdag)
library(dagitty)
library(DiagrammeR)

```


### Objective 3: Breeding Timing - missing data

```{r}
library(DiagrammeR)

grViz("
digraph dag {
  graph [layout = neato, splines = true, overlap = false]

  node [
    fontname = Helvetica,
    fontsize = 22,
    penwidth = 2,
    shape = box,
    margin = 0.18
  ]

  edge [
    penwidth = 2,
    arrowsize = 0.7
  ]

  # --- nodes ---
  T  [label='T', pos='0,2!']      # latent timing
  S  [label='S', pos='2,2!']      # breeding success
  Y  [label='Y', pos='0,0!']      # year / time index
  W  [label='W', pos='2,0!']      # weather

  Tstar [
    label='T*',
    shape=circle,
    fixedsize=true,
    width=0.75,
    height=0.75,
    fontsize=20,
    pos='4,2!'
  ]

  # --- causal structure ---
  T -> S
  S -> Tstar

  Y -> T
  Y -> S
  Y -> W

  W -> T
  W -> S
}
")



```

Year (Y) represents background temporal variation that may influence both local weather conditions (W) and breeding processes through unmeasured long-term ecological or population-level changes. Weather is hypothesised to affect true breeding timing (T), acting as a short-term environmental cue, and to influence breeding success (S) through conditions experienced during incubation and early chick development. Breeding timing may further affect breeding success, reflecting potential fitness consequences of breeding earlier or later in the season. Observed timing (T*) represents the timing information available in the dataset and depends on both true breeding timing and breeding success, as unsuccessful breeding attempts are less likely to yield reliable timing records. This highlights that missing timing data are biologically structured rather than random, and that weather may influence both breeding timing and the probability that timing is observed. 

### Objective 1: Breeding effort 

```{r}
library(DiagrammeR)

grViz("
digraph effort_dag {
  graph [layout = neato, splines = true, overlap = false]

  node [
    fontname = Helvetica,
    fontsize = 22,
    penwidth = 2,
    shape = box,
    margin = 0.18
  ]

  edge [
    penwidth = 2,
    arrowsize = 0.6
  ]

  # Nodes (matching your hand sketch)
  Y  [label='Y',  pos='0,2!']   # year / time index
  W  [label='W',  pos='0,0!']   # weather
  U  [label='U',  pos='3,2!']   # unmeasured long-term drivers
  BE [label='BE', pos='3,0!']   # breeding effort

  # Edges (exact causal story)
  Y -> U
  Y -> W
  W -> U
  U -> BE
  W -> BE
}
")

```
Causal structure linking temporal variation, weather, unmeasured ecological processes, and breeding effort (BE), measured as the annual number of active nests. 

Year (Y) is included as a temporal index representing the passage of time and captures long-term trends in both observed and unobserved processes. Weather (W) represents short-term and interannual variation in environmental conditions (e.g. temperature, rainfall, wind, and extreme events) and is structured by year. Unmeasured long-term drivers (U) represent slowly varying ecological and contextual processes that were not directly observed, such as food availability, adult condition, population state, management context, or land-use change. These processes are assumed to influence breeding effort directly and to vary through time, and may also be partially influenced by weather. Breeding effort is therefore determined by both short-term weather effects and longer-term unmeasured processes, while the strong temporal trend in breeding effort is interpreted primarily as arising from variation in U rather than from weather alone. This shows that links between weather and breeding effort might simply reflect the fact that both change over time, or act through other processes, rather than weather having a direct effect.



:::

 


























































































